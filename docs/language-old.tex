\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}

\include{styles/bashconsole}
\include{styles/language}

\setlength{\parindent}{0pt}

\title{Language Documentation}
\author{Ruben Saunders}
\date{September 2024}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Overview}

The compiler takes one or more source files and produces single, linked assembly file.

\subsection{Command-Line Interface}

The compiler executable is called as follows:

\medskip
\begin{lstlisting}[style=bashconsole]
$ ./compiler <input_file> -o <output_file> [flags]
\end{lstlisting}

The output file is provided after the \texttt{-o} flag.
The following optional flags are available:
\begin{itemize}
    \item \texttt{-d}: enables debug mode.
    In this mode, detailed results from each step are output to the console.
    \item \texttt{-l <file>}: for each file, writes lexed source to \texttt{file} as XML.
    \item \texttt{-p <file>}: for each file, writes parsed contents to \texttt{file} as XML.
\end{itemize}

\subsection{Process Flow}

The process flow bears resemblance to the assembler, and hence will be summarised in less detail.

\begin{enumerate}
    \item For each input file:
    \begin{enumerate}
        \item Open the file.
        \item Pre-process the file.
        \item Parse the file, construct an AST.
        \item Create symbol table.
    \end{enumerate}
    \item Link referenced but undefined symbols using all symbol tables.
    \item Compile components to assembly.
    \item Write all components to assembly output.
\end{enumerate}

\section{General Syntax}

Each file is parsed into tokens, which are then grouped in recognisable sequences.
Tokens are grouped into lines; lines are separated by: a newline, unless the previous token was an operator or the parser is in a bracketed group `\texttt{(...)}';
or a semicolon `\texttt{;}'.

Each file has a global scope, which may only consist of global variables, functions, and data definitions.
Below are outlined key points about syntax; specifics will be documented later.

\begin{itemize}
    \item Single-line commends have the form \texttt{// ...} and last until a newline character is encountered.
    \item Multi-line commands have the form \texttt{/* ... */}.
    \item Identifiers start with a lowercase character which may then be followed by any number of characters, numbers, or underscores.
    That is, \texttt{[a-z][a-zA-Z0-9\_]*}.
    \item Datatype identifiers start with an uppercase character which may then be followed by any number of characters, numbers, or underscores.
    That is, \texttt{[A-Z][a-zA-Z0-9\_]*}.
\end{itemize}

\section{Language Options}

These options are provided to configure the language, enforce syntax, or modify reporting.
They are listed internally, but currently cannot be changed without editing \texttt{src/LanguageOptions.cpp}.

Some options take the form of a reporting level.
The possible values are:
\begin{itemize}
    \item \texttt{-1} -- hidden; disables the reporting.
    \item \texttt{0} -- notice.
    \item \texttt{1} -- warning.
    \item \texttt{2} -- error; compilation is halted.
\end{itemize}

\subsection{\texttt{allow\_alter\_entry}}

\textbf{Default: \texttt{true}}

Enables use of the \texttt{entry} keyword to alter the program's entry point.

\subsection{\texttt{allow\_shadowing}}

\textbf{Default: \texttt{true}}

Enables variable shadowing, wherein existing variables may be re-defined in the same scope.

\begin{lstlisting}[language=CustomLang]
decl a: byte
// ...
decl a: word
\end{lstlisting}

\subsection{\texttt{must\_declare\_functions}}

\textbf{Default: \texttt{false}}

Enforces the declaration of a function signature prior to its definition.
That is, all \texttt{func ...} must be preceded by a matching \texttt{decl func ...}.

\begin{lstlisting}[language=CustomLang]
decl func add(int, int) -> int
// ...
func add(x: int, y: int) -> int { ... }
\end{lstlisting}

\section{Types}

Each variable has a type, indicating tha form, size, and purpose of some data.

\paragraph*{Type Coercion}
This refers to how a value takes on a type given context, and occurs implicitly and only if necessary.
For example, the literal \texttt{42} could take on different types depending on the variable's type.
Another example would be adding two integers of different types; the smaller is coerced into the larger type.

\paragraph*{Type Casting}
This is the explicit conversion of data between two types.
Examples would be: down-sizing an integer value, changing a pointer type.
This is done by preceding a variable or value by a bracketed type.
For example,

\begin{lstlisting}[language=CustomLang]
decl pi: float = 3.14159
decl pi_approx: int = (int) pi
\end{lstlisting}

\subsection{Primitive Types}

These types are built-in to the compiler.

\begin{itemize}
    \item \texttt{byte} -- represents an unsigned 8-bit integer.
    \item \texttt{int} -- represents a signed 32-bit integer.
    \item \texttt{uint} -- represents an unsigned 32-bit integer.
    \item \texttt{word} -- represents a signed 64-bit integer (a processor word).
    \item \texttt{uword} -- represents an unsigned 64-bit integer (a processor word).
    \item \texttt{float} -- represents a 32-bit floating-point number.
    \item \texttt{double} -- represents a 64-bit floating-point number.
\end{itemize}

\paragraph*{Numeric Literals}
Numbers are specified as a sequence of digits.
A different base may be specified by prefixing the literal with \texttt{0}\(x\) where \(x\) is one of

\begin{itemize}
    \item \texttt{b} -- binary, base-2.
    \item \texttt{o} -- octal, base-8.
    \item \texttt{d} -- decimal, base-10 (the default).
    \item \texttt{x} -- hexadecimal, base-16.
\end{itemize}

By default, integer literals are \texttt{int}s, unless the value exceeds the integer capacity, or the literal has a \texttt{w} suffix.

\paragraph*{Decimal Literals}

A numeric literal becomes a float if a decimal point `\texttt{.}' is encountered.

For floating points, the default is \texttt{double} unless \texttt{f} is suffixed.

\subsection{User-Defined Types}

These are types defined using the \texttt{data} keyword, with the syntax

\begin{lstlisting}[language=CustomLang]
decl data Name
data Name {
    field1: type1,
    ...
}
\end{lstlisting}

That is, the datatype \texttt{Name} contains the listed fields, which are the listed types.
Field declarations are separated by newlines, or by commas.

\paragraph*{Member Access}

Members may then be accessed via the dot `\texttt{.}' operator.

\begin{lstlisting}[language=CustomLang]
data Vec { x: int, y: int }
decl v: Vec
v.x // => 0
\end{lstlisting}

\paragraph*{As Parameters}

Variables of a user-defined datatype are passed around as references, meaning that modifications to said parameters modify the original.
For example,

\begin{lstlisting}[language=CustomLang]
func set(v: Vec, n: int) {
    v.x = n
    v.y = n
}

decl v: Vec // v.x = 0
set(v, 5) // v.x = 5
\end{lstlisting}

\paragraph*{Casting}

Values of user-defined datatypes cannot be cast between eachother.
If necessary, cast to a pointer type first.

\begin{lstlisting}[language=CustomLang]
decl data Vec2, Vec3
decl v: Vec2
// ...
decl v: Vec3 = *(*Vec3) @v
\end{lstlisting}

\subsection{Pointers}

Pointers are special types which contain the memory address (location) of a variable of some type.
Pointers are declared with a star, followed by the datatype at the location.
For example,

\begin{lstlisting}[language=CustomLang]
decl n: int = 42
decl p: *int = @n
\end{lstlisting}

If the type is unknown, one uses the special \texttt{*unknown} type.
Note that pointers themselves are nothing but integers under the hood, specifically a \texttt{uword}.

\paragraph*{Creating Pointers}
The memory location of a variable may be retrieved using the address-of `\texttt{@}' unary operator.
Note, such operators are evaluated at compile-time.
As seen above, the variable \(t\) produces pointer \texttt{*\(t\)}.

\paragraph*{Pointer Arithmetic}
Pointers supports both the addition `\texttt{+}' and subtraction `\texttt{-}' operators with integers.
Such operations are considered to intend ``move the pointer left/right by \(n\) units'', the unit size dependent on the pointer type.

\begin{lstlisting}[language=CustomLang]
decl p: *int = 10
p + 2 // p + 2 * sizeof(int) = 18
// vs
decl p: *byte = 10
p + 2 // p + 2 * sizeof(byte) = 12
\end{lstlisting}

\paragraph*{Pointer Dereferencing}
This refers to retrieving a value at a pointer, and is done via the star `\texttt{*}' unary operator.
As expected of the complement of \texttt{@}, this strips a star from the type, and hence is only applied to pointer types.
Following the example, the value of \texttt{n} may be recovered by

\begin{lstlisting}[language=CustomLang]
decl n2: int = *p
\end{lstlisting}

\paragraph*{Casting}
As pointers are but integers, they may be cast as such.
That is, integers may be cast to pointers with any number of stars, and vice versa.

\begin{lstlisting}[language=CustomLang]
decl n: int = 5,
    pint: *int = n,
    pfloat: *float = pint // would also work with `= n'
\end{lstlisting}

\subsection{Arrays}

Arrays are contiguous blocks of memory which may hold a sequence of data of one type.
Essentially, arrays are pointers, except \texttt{sizeof} returns the size in bytes of the array, not of the pointer type.

An array type is declared by suffixing the type with square brackets `\texttt{[]}'.
Note that the pointer specifier `\texttt{*}' is more binding than the array specifier.
That is, \texttt{*int[]} is a pointer to an array of integers, whereas \texttt{(*int)[]} is an array of integer pointers.

The array size is optionally given between the square brackets.

\begin{lstlisting}[language=CustomLang]
decl nums: int[5]
sizeof(nums) // -> 5 * sizeof(int) = 20
\end{lstlisting}

Note that an arrays size must be known at compile time (e.g, a macro or a constant with known value).
If a size is not specified, the declaration \textbf{must} be initialised, from which the size will be deduced.

\begin{lstlisting}[language=CustomLang]
decl nums: int[] = { 1, 2, 3, 4, 5 }
sizeof(nums) // -> 5 * sizeof(int) = 20
\end{lstlisting}

\subsection{Constants}

If a type is preceded by the \texttt{const} keyword, this type is marked as constant and any attempted changes to this type is forbidden.
Additionally, attempting to strip a \texttt{const} type of its constant status is forbidden (but copying to a non-constant is allowed).

\begin{lstlisting}[language=CustomLang]
decl pi: const float = 3.14159
pi = 5 // error! `pi' is marked const
decl pi: float = pi
pi = 5 // permitted, as shadow is not const
\end{lstlisting}

\section{Variables}

Variables are but labels to reserved location in memory.
When defined, variables are assigned a name and a datatype, which dictates the size in bytes of the reserved location.
An example would be

\begin{lstlisting}[language=CustomLang]
decl x: int
\end{lstlisting}

Values may be assigned to variables using the assignment operator `\texttt{=}'.
Note the type coercion/casting behaviours described previously.

\subsection{Multi-Declaration}

Commas may be used to separate declarations and, hence, declare multiple symbols per keyword.
Each declaration may be of a different type.

\begin{lstlisting}[language=CustomLang]
decl a: byte , b: int , c: word
\end{lstlisting}

\subsection{Scope}

``Scope'' refers to where a variable exists.
The global scope is the top-most scope where all top-level functions and variable reside.
Symbols in the global scope may be accessed anywhere in the program.

On the other hand, local scope is not all-encompassing.
A new local scope is introduced in every block.
Variables defined in such a scope are only accessible from within that function; referencing them outside will result in an error.

When a variable is referenced, the scopes will be searched as a stack; that is, local first, global last.

\begin{lstlisting}[language=CustomLang]
decl n: int = 0

func f1 {
    n++ // this will increment the global `n'
}

func f2 {
    decl n: int = 1
    n++ // this will increment the local `n' declared above
}
\end{lstlisting}

To see an example of creating a local scope that is not a function definition:

\begin{lstlisting}[language=CustomLang]
decl n: int = 0 // n = 0

{
    decl n: int = 2 // n = 2
    n++ // n = 3
}

// n = 0
\end{lstlisting}

\section{Functions}

Functions are name-associated sections of code which may be called, possible with arguments, and may return a value.
They are defined using the \texttt{func} keyword.
For use before definitions, signatures may be declared using the compound \texttt{decl func} keyword.

\begin{lstlisting}[language=CustomLang]
decl func add(int, int) -> int
func add(a: int, b: int) {
    return a + b
}
\end{lstlisting}

\begin{itemize}
    \item In declarations, parameter names are not required.
    \item If no parameters are required, it is possible to omit the brackets entirely.
    \item If no return type is required, omit the arrow `\texttt{->}' and the type.
    \item If declared, the definition does not require a return type as this can be inferred from its declared signature.
\end{itemize}

\subsection{Overloading}

Function overloading is supported, meaning that a function name may be re-used with a different signature.
For example,

\begin{lstlisting}[language=CustomLang]
decl func add(int, int) -> int
decl func add(float, float) -> float
\end{lstlisting}

\subsection{Entry Point}

All programs have an entry point.
By default, it is \texttt{main}, taking zero or more integers, and optionally returning an integer.

A new entry point may be defined using the \texttt{entry} keyword, by following the keyword by the entry point's name and type.
Note, this is a function signature.

\begin{lstlisting}[language=CustomLang]
entry start(int) -> int
\end{lstlisting}

Only one entry point per program is permitted.
Once encountered, future encounters of \texttt{entry} will result in an error.

\subsection{Compile-Time Functions}

These ``functions'' are resolved in the compilation stage.

\paragraph*{\texttt{sizeof(\(t\))}}
This returns the size, in bytes, of the argument \(t\).
\(t\) may be a type name, or a variable, in which case the size of the variable's type will be calculated.

\begin{lstlisting}[language=CustomLang]
sizeof(int) // -> 4
\end{lstlisting}

\paragraph*{\texttt{register(\(r\))}}
This may be used in expressions, and returns the contents of register \(r\) as a word.
\(r\) is the name of a register, same as in the assembly code but without the dollar `\texttt{\$}'.

\begin{lstlisting}[language=CustomLang]
register(sp) // reads $sp
\end{lstlisting}

\section{Operators}

\textit{TODO}

\end{document}
