\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{multirow}
\usepackage{float}

\include{styles/bashconsole}
\include{styles/language}

\setlength{\parindent}{0pt}

\title{Language Documentation}
\author{Ruben Saunders}
\date{January 2025}

\begin{document}
    \maketitle
    \tableofcontents

    \newpage

    \section{Introduction}\label{sec:introduction}

    This document will contain information about the Edel language.
    As an educational tool, it is designed to be simple and easy to learn and operate, with the goals of being clear a readable.
    Each section is written from the perspective of little programming knowledge.

    \subsection{Overview}\label{subsec:overview}

    As the most wide-spread paradigm, this language is imperative by nature.
    Its syntax is inspired by C, but borrows features from C++ such as namespaces and operator overloading.
    However, unlike these two languages, names are \textit{forward declared}, meaning they can be used prior to their definition.
    This foregoes the need for header files of explicit forward declarations as in C and C++, and allows a much freer programming experience similar to modern languages.

    % TODO talk about imports

    \subsection{The Compiler}\label{subsec:the-compiler}

    A program consists of one file (the entry file), which is compiled by the compiler to produce an assembly output.

    \medskip
    \begin{lstlisting}[style=bashconsole]
$ ./compiler <input_file> [-o <output_file>] [flags]
    \end{lstlisting}
    \medskip

    Where \texttt{[flags]} are as follows:
    \begin{itemize}
        \item \texttt{--ast} - prints the parsed program's AST.
    \end{itemize}
    Note that the output file is optional.

    \subsection{``Hello, World''}\label{subsec:hello-world}

    As is customary, a quick ``hello world'' program written in Edel.

    \begin{lstlisting}[language=CustomLang]
func main() {
    print("Hello, world\n");
}
    \end{lstlisting}

    \section{Basic Syntax}\label{sec:basic-syntax}

    Inspires by C, Edel is not whitespace sensitive, with scopes marked by braces \texttt{\{\}}.
    Semicolons are not requires after every line, namely closing braces, but are required after expressions.

    Comments come in two forms: single-- and multi-line.
    Single-line comments \texttt{// ...} comment out the remainder of the current line;
    multi-line comments \texttt{/* ... */} comment out anything they enclose.

    \subsection{Variables}\label{subsec:variables-&-assignment}

    Using the common analogy, a variable is like a labeled box which stored data.
    Each box has a \textit{type} which tells us what it stores.
    For example, ``int 3''.
    More technically, a variable is a location in memory where data can be stored, with its type determining the size of the variable and how its value can be used.

    Variables are defined using the \texttt{let} keyword, with the variables type following a colon.
    For example, to define our ``int 3'' from earlier,
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3;
    \end{lstlisting}

    If required, multiple variables can be defined in the same \texttt{let} statement.
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3, bar: float = 3.14;
    \end{lstlisting}

    If the type is omitted, it is deduced from the assigned value.
    Hence, this can only be done if the variable is assigned.
    \begin{lstlisting}[language=CustomLang]
let foo = 3, bar = 3.14;
    \end{lstlisting}
    (In this case, both variables adopt the types as previously written.)

    \subsubsection{Shadowing}

    Edel allows names to be \textit{shadowed}, meaning a variable may re-use a variable's name.

    In non-local shadowing, the previous definition becomes visible again after the current scope is exited.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
{
    let foo = 2;
    // foo = 2
}
// foo = 1
    \end{lstlisting}

    Edel also allows local shadowing.
    In this case, once shadowed, the previous definition is essentially lost and cannot be referenced.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
// foo = 1
let foo = 2;
// foo = 2
    \end{lstlisting}

    \subsubsection{Constants}

    Constants are values that, once defined, cannot be changed.
    Constants may be defined using the \texttt{const} keyword in place of \texttt{let}.

    \begin{lstlisting}[language=CustomLang]
const pi = 3.14159;
    \end{lstlisting}

    In the case of multiple definitions, \textit{all} symbols will be defined as const.

    \subsection{Expressions \& Statements}\label{subsec:expressions-&-statements}

    Generally, a statement is some code which does not produce a value, whereas an expression does.
    In Edel, \textit{everything} is an expression, with statements, by default, returning the unit type `\texttt{()}'.

    Expressions are expected to be terminated by a semicolon.
    The exception to this is the final expression in a block; if omitted, the block `returns' the result of this expression.

    \begin{lstlisting}[language=CustomLang]
let a = { 1 + 2; }; // a = ()
let b = { 1 + 2 }; // b = 3
let c = { let z = 2 * b; z } + 2; // c = 8
    \end{lstlisting}

    Note that only the last expression in a block may have their semicolon emitted.
    By always terminating expressions, the block will act like a statement.

    \subsubsection{Value Categories}

    Each expression, be it an operator with operands, literals, or variable names etc., is characterised by a \textit{type} and a \textit{category}.
    Types, covered in section ~\ref{sec:types}, give meaning to data and what it means in context, whereas the category tells dictates \textit{how} a value can be used.

    Edel has two categories, be them l-- and r-values.
    The former is a value which refers to a memory location, such as variables, while the latter has no identifiable location in memory.
    The \textit{l} and \textit{r} stand for \textit{left} and \textit{right} because the respective values may appear on the left-- or right-hand side of an assignment operator.
    That is,

    \begin{lstlisting}[language=CustomLang]
a = 1; // a (lvalue) = 1 (rvalue)
    \end{lstlisting}

    As an rvalue has no identifiable location, it cannot be assigned to, nor can it be access via the dot `\texttt{.}' operator.
    Instances of misuse of an l-- or rvalue results in an error ``\texttt{expected l/rvalue, got type}''.

    \begin{lstlisting}[language=CustomLang]
1 = 2; // error: expected lvalue, got i32
true.a; // error: expected lvalue, got bool

namespace maths {}
maths + 1; // error: expected rvalue, got namespace
    \end{lstlisting}

    \subsection{Code Blocks}\label{subsec:code-blocks}

    As a whitespace-ignorant language, Edel uses blocks to denote structure and scope.
    A block is introduced by braces \texttt{\{\}} and contains a section of code.
    A block may be written anywhere a statement is expected, allowing the programmer to instead write multiple statements in its body.
    Finally, in Edel, every block introduces a new lexical scope~\ref{sec:scope}.

    \section{Types}\label{sec:types}

    Continuing the analogy from variables, a type is a label that tells the program what kind of data a variable holds.
    Every variable and value has a type; a value without a type is meaningless, as a type gives data a meaning.

    \subsection{Primitive Types}

    Primitive types are a subset of those provided by the compiler representing atomic values, such as numbers.

    \medskip
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|l|}
            \hline
            \textbf{Type} & \textbf{Alias} & \textbf{Description} \\
            \hline
            \texttt{bool} & & A truth value -- either \texttt{true} or \texttt{false} \\
            \hline
            \texttt{u8} & \texttt{byte} & Unsigned 8-bit integer \\
            \texttt{i8} & & Signed 8-bit integer \\
            \hline
            \texttt{u16} & & Unsigned 16-bit integer \\
            \texttt{i16} & & Signed 16-bit integer \\
            \hline
            \texttt{u32} & & Unsigned 32-bit integer \\
            \texttt{i32} & \texttt{int} & Signed 32-bit integer \\
            \hline
            \texttt{u64} & & Unsigned 64-bit integer \\
            \texttt{i64} & \texttt{long} & Signed 64-bit integer \\
            \hline
            \texttt{f32} & \texttt{float} & 32-bit floating-point number \\
            \texttt{f64} & \texttt{double} & 64-bit floating-point number \\
            \hline
        \end{tabular}
        \caption{Primitive Types}\label{tab:primitive-types}
    \end{table}

    % TODO type hierarchy

    These types have the following type hierarchy:
    \begin{itemize}
        \item \texttt{int8 < int16 < int32 < int64}
        \item \texttt{uint8 < uint16 < uint32 < uint64}
        \item \texttt{uint\(n\) < int\((n+k)\)}
        \item \texttt{float32 < float64}
        \item \texttt{[u]int\(n\) < float64}
        \item \texttt{[u]int\(n\) < float32} where \(n < 64\).
    \end{itemize}

    Note that \texttt{bool} is not related to anything.
    Unlike in other language, \texttt{bool} is treated as a distinct type with abstract true/false values, rather than a synonym for integers 1/0, respectively.

    \subsection{Pointer Types}\label{subsec:pointer-types}

    The use of pointers is designed to be minimal in Edel, but they are available nonetheless.
    Simply put, a pointer stores the \textit{location} (or \textit{address}) of a variable, which can then be used to later reference and access that data.
    A pointer is indicated by a star `\texttt{*}' preceding the type;
    that is, type \texttt{*T} is telling the compiler \textit{hey, see this location? Data of type} \texttt{T} \textit{is stored there}.

    Subsection ~\ref{subsec:address-of-&-dereferencing} explains the use of the \texttt{\&} and \texttt{*} unary operators to manipulate pointers.

    Pointers do not fit into the type hierarchy, and cannot be implicitly cast.
    For safety, it is best not to cast pointer types unless one really knows and understands what is going on.

    \subsection{Casting}\label{subsec:type-casting}

    Casting refers to the changing of a type, and can be split into two categories: implicit, and explicit.

    Implicit casting is where a cast is done behind-the-scenes.
    Type \(a\) may be implicitly cast (also known as \textit{coerced}) to another type \(b\) if and only if \(a < b\), that is, \(a\) is a subtype of \(b\).
    In other words, \(a\) can be coerced into \(b\) if \(b\) is sufficient to represent \(a\) without data loss.
    For example, \texttt{u8} may be coerced into \texttt{u64}, or \texttt{float} into \texttt{double}, but \textbf{not} \texttt{i32} into \texttt{i16}.
    Implicit casting is done automatically in the following:

    \begin{lstlisting}[language=CustomLang]
let a: double = 3.14; // float -> double
    \end{lstlisting}

    On the other hand, explicit casting violates these rules, and hence the cast may be \textit{explicit}.
    Note that not all datatypes may be cast between each-other using explicit casting, but the subtype relationships may be largely violated.

    \begin{lstlisting}[language=CustomLang]
let a: u8 = 42; // error!
let a = 42 as u8; // i32 -> u8
    \end{lstlisting}

    \section{Functions}

    \section{Operators}

    Operators are special symbols which combine one or two expressions, known as unary and binary operators, respectively.
    The table below lists the built-in operators alongside their behaviour and associativity.
    Operators start from tightest to loosest precedence, with those of the same precedence grouped.

    \begin{table}[h]
        \centering
        \caption{Built-In Operators}
        \begin{tabular}{|l|l|c|c|}
            \hline
            \textbf{Operator} & \textbf{Description} & \textbf{Associativity} & \textbf{Overloadable} \\
            \hline
            \texttt{a.b} & Member access & \(\longrightarrow\) & No \\
            \hline
            \texttt{a()} & Function call & \(\longrightarrow\) & Yes \\
            \hline
            \texttt{(T) a} & Primitive cast & \multirow{4}{*}{\(\longleftarrow\)} & \multirow{4}{*}{No} \\
            \texttt{\&a} & Address-of & & \\
            \texttt{*a} & Dereference & & \\
            \texttt{registerof a} & Register lookup & & \\
            \hline
            \texttt{-a} & Negation & \multirow{3}{*}{\(\longleftarrow\)} & \multirow{3}{*}{Yes} \\
            \texttt{~a} & Bitwise NOT & & \\
            \texttt{!a} & Boolean NOT & & \\
            \hline
            \texttt{a as T} & Cast & \(\longleftarrow\) & No \\
            \hline
            \texttt{a * b} & Multiplication & \multirow{3}{*}{\(\longrightarrow\)} & \multirow{3}{*}{Yes} \\
            \texttt{a / b} & Division & & \\
            \texttt{a \% b} & Modulo (remainder) & & \\
            \hline
            \texttt{a + b} & Addition & \multirow{2}{*}{\(\longrightarrow\)} & \multirow{2}{*}{Yes} \\
            \texttt{a - b} & Subtraction & & \\
            \hline
            \texttt{a << b} & Bitwise left shift & \multirow{2}{*}{\(\longrightarrow\)} & \multirow{2}{*}{Yes} \\
            \texttt{a >> b} & Bitwise left shift & & \\
            \hline
            \texttt{a == b} & \multirow{6}{*}{Relational operators} & \multirow{6}{*}{\(\longrightarrow\)} & \multirow{6}{*}{Yes} \\
            \texttt{a != b} & & & \\
            \texttt{a < b} & & & \\
            \texttt{a <= b} & & & \\
            \texttt{a > b} & & & \\
            \texttt{a >= b} & & & \\
            \hline
            \texttt{a \& b} & Bitwise AND & \multirow{1}{*}{\(\longrightarrow\)} & Yes \\
            \hline
            \texttt{a \string^ b} & Bitwise XOR & \multirow{1}{*}{\(\longrightarrow\)} & Yes \\
            \hline
            \texttt{a | b} & Bitwise OR & \multirow{1}{*}{\(\longrightarrow\)} & Yes \\
            \hline
            \texttt{a = b} & Assignment & \multirow{1}{*}{\(\longleftarrow\)} & No \\
            \hline
        \end{tabular}\label{tab:builtin-operators}
    \end{table}

    \subsection{Casting}\label{subsec:op-casting}

    The concept of casting is explained in subsection ~\ref{subsec:type-casting}.
    Note that the table above presents two casting operators: \texttt{(T) a} and \texttt{a as T}.

    The former is a \textit{primitive} cast, meaning it only supports casting to primitive, atomic types.
    This cast is direct and is ignorant of the type of \texttt{a} and whether the cast is meaningful.

    The latter, using the \texttt{as} keyword, is a straightforward explicit cast.
    There are no restrictions on \texttt{T} and, as explained in subsection ~\ref{subsec:type-casting}, this cast still must obey some rules.

    \begin{lstlisting}[language=CustomLang]
let a = (int) 3.14; // ok
let b = (*int) 0; // error
let c = 0 as *int; // ok
    \end{lstlisting}

    Also note the difference in precedence: the \texttt{as} cast is slightly looser than other unary operators.

    \begin{lstlisting}[language=CustomLang]
!1 as bool; // same as `(!1) as bool' NOT `!(1 as bool)'
    \end{lstlisting}

    \subsection{Address-Of \& Dereferencing}\label{subsec:address-of-&-dereferencing}

    Both operations involve pointers, with the former generating pointers, and the latter `consuming' them.

    The address-of operator, \texttt{\&}, calculates the memory address of a symbol.
    That is, if \texttt{a: T}, then \texttt{\&a} is of type \texttt{*T}.

    Dereferencing, then, is address-of's twin; it retrieved the value stored at a pointer.
    That is, if \texttt{p: *T}, then \texttt{*a} is of type \texttt{T}.

    \begin{lstlisting}[language=CustomLang]
let a: int = 5;
let p: *int = &a;
let b: int = *p; // then a == b
    \end{lstlisting}

    \subsection{Register Lookup}

    This is a lower-level operator meant for exploration of the processor's registers.

    Expecting a symbol argument, the \texttt{registerof} operator returns the index (offset) of where the given symbol is located.
    This allows one to gain insight into the register allocation algorithm.

    For example, given the basic program below, one would expect the following.

    \begin{lstlisting}[language=CustomLang]
let a = 5;
registerof a; // = 11, corresponding to $r1
    \end{lstlisting}

    If the symbol has not been loaded into registers (i.e., it has not been used at all/recently), the operator returns \(-1\).

    \begin{lstlisting}[language=CustomLang]
let a: int;
registerof a; // = -1
    \end{lstlisting}

    \section{Control Flow}

    \section{Scope \& Name Resolution}\label{sec:scope}

    \section{Modules \& Imports}

    \section{Standard Library}

\end{document}
