\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{multirow}
\usepackage{float}

\include{styles/bashconsole}
\include{styles/language}

\setlength{\parindent}{0pt}

\title{Language Documentation}
\author{Ruben Saunders}
\date{January 2025}

\begin{document}
    \maketitle
    \tableofcontents

    \newpage

    \section{Introduction}\label{sec:introduction}

    This document will contain information about the Edel language.
    As an educational language, it is designed to be simple and easy to learn and operate, with the goals of being clear a readable.
    Each section is written from the perspective of little programming knowledge.

    \subsection{Overview}\label{subsec:overview}

    As the most wide-spread paradigm, this language is imperative by nature.
    Its syntax is inspired by C, but borrows features from C++ such as namespaces and operator overloading.
    However, unlike these two languages, names (except variables) are \textit{forward declared}, meaning they can be used prior to their definition.
    This foregoes the need for header files of explicit forward declarations as in C and C++, and allows a much freer programming experience similar to modern languages.

    % TODO talk about imports

    \subsection{The Compiler}\label{subsec:the-compiler}

    A program consists of one file (the entry file), which is compiled by the compiler to produce an assembly output.

    \medskip
    \begin{lstlisting}[style=bashconsole]
$ ./compiler <input_file> [-o <output_file>] [flags]
    \end{lstlisting}
    \medskip

    Where \texttt{[flags]} are as follows:
    \begin{itemize}
        \item \texttt{--ast} - prints the parsed program's AST.
        \item \texttt{--[no-]function-placeholder} - changes behaviour of a function declaration; see subsection ~\ref{subsec:function-declaration}.
        \item \texttt{--[no-]indentation} - adds/removes indentation from generated assembly.
    \end{itemize}
    Note that the output file is optional.

    \subsection{``Hello, World''}\label{subsec:hello-world}

    As is customary, a quick ``hello world'' program written in Edel.

    \begin{lstlisting}[language=CustomLang]
func main() {
    print("Hello, world\n");
}
    \end{lstlisting}

    \section{Basic Syntax}\label{sec:basic-syntax}

    Inspires by C, Edel is not whitespace sensitive, with scopes marked by braces \texttt{\{\}}.
    Semicolons are not requires after every line, namely closing braces, but are required after expressions.

    Comments come in two forms: single-- and multi-line.
    Single-line comments \texttt{// ...} comment out the remainder of the current line;
    multi-line comments \texttt{/* ... */} comment out anything they enclose.

    \subsection{Variables}\label{subsec:variables-&-assignment}

    Using the common analogy, a variable is like a labeled box which stored data.
    Each box has a \textit{type} which tells us what it stores.
    For example, ``int 3''.
    More technically, a variable is a location in memory where data can be stored, with its type determining the size of the variable and how its value can be used.

    Variables are defined using the \texttt{let} keyword, with the variables type following a colon.
    For example, to define our ``int 3'' from earlier,
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3;
    \end{lstlisting}

    If required, multiple variables can be defined in the same \texttt{let} statement.
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3, bar: float = 3.14;
    \end{lstlisting}

    If the type is omitted, it is deduced from the assigned value.
    Hence, this can only be done if the variable is assigned.
    \begin{lstlisting}[language=CustomLang]
let foo = 3, bar = 3.14;
    \end{lstlisting}
    (In this case, both variables adopt the types as previously written.)

    \subsubsection{Shadowing}

    Edel allows names to be \textit{shadowed}, meaning a variable may re-use a variable's name.

    In non-local shadowing, the previous definition becomes visible again after the current scope is exited.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
{
    let foo = 2;
    // foo = 2
}
// foo = 1
    \end{lstlisting}

    Edel also allows local shadowing.
    In this case, once shadowed, the previous definition is essentially lost and cannot be referenced.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
// foo = 1
let foo = 2;
// foo = 2
    \end{lstlisting}

    \subsubsection{Constants}

    Constants are values that, once defined, cannot be changed.
    Constants may be defined using the \texttt{const} keyword in place of \texttt{let}.

    \begin{lstlisting}[language=CustomLang]
const pi = 3.14159;
    \end{lstlisting}

    In the case of multiple definitions, \textit{all} symbols will be defined as const.

    \subsection{Expressions \& Statements}\label{subsec:expressions-&-statements}

    Generally, a statement is some code which does not produce a value, whereas an expression does.
    In Edel, \textit{everything} is an expression, with statements, by default, returning the unit type `\texttt{()}'.

    Expressions are expected to be terminated by a semicolon.
    The exception to this is the final expression in a block; if omitted, the block `returns' the result of this expression.

    \begin{lstlisting}[language=CustomLang]
let a = { 1 + 2; }; // a = ()
let b = { 1 + 2 }; // b = 3
let c = { let z = 2 * b; z } + 2; // c = 8
    \end{lstlisting}

    Note that only the last expression in a block may have their semicolon emitted.
    By always terminating expressions, the block will act like a statement.

    \subsubsection{Value Categories}

    Each expression, be it an operator with operands, literals, or variable names etc., is characterised by a \textit{type} and a \textit{category}.
    Types, covered in section ~\ref{sec:types}, give meaning to data and what it means in context, whereas the category tells dictates \textit{how} a value can be used.

    Edel has two categories, be them l-- and r-values.
    The former is a value which refers to a memory location, such as variables, while the latter has no identifiable location in memory.
    The \textit{l} and \textit{r} stand for \textit{left} and \textit{right} because the respective values may appear on the left-- or right-hand side of an assignment operator.
    That is,

    \begin{lstlisting}[language=CustomLang]
a = 1; // a (lvalue) = 1 (rvalue)
    \end{lstlisting}

    As an rvalue has no identifiable location, it cannot be assigned to, nor can it be access via the dot `\texttt{.}' operator.
    Instances of misuse of an l-- or rvalue results in an error ``\texttt{expected l/rvalue, got type}''.

    \begin{lstlisting}[language=CustomLang]
1 = 2; // error: expected lvalue, got i32
true.a; // error: expected lvalue, got bool

namespace maths {}
maths + 1; // error: expected rvalue, got namespace
    \end{lstlisting}

    \subsection{Code Blocks}\label{subsec:code-blocks}

    As a whitespace-ignorant language, Edel uses blocks to denote structure and scope.
    A block is introduced by braces \texttt{\{\}} and contains a section of code.
    A block may be written anywhere a statement is expected, allowing the programmer to instead write multiple statements in its body.
    Finally, in Edel, every block introduces a new lexical scope~\ref{sec:scope}.

    \section{Types}\label{sec:types}

    Continuing the analogy from variables, a type is a label that tells the program what kind of data a variable holds.
    Every variable and value has a type; a value without a type is meaningless, as a type gives data a meaning.

    \subsection{Primitive Types}

    Primitive types are a subset of those provided by the compiler representing atomic values, such as numbers.

    \medskip
    \begin{table}[H]
        \centering
        \begin{tabular}{|c|c|c|l|}
            \hline
            \textbf{Type} & \textbf{Alias} & \textbf{Description} \\
            \hline
            \texttt{bool} & & A truth value -- either \texttt{true} or \texttt{false} \\
            \hline
            \texttt{u8} & \texttt{byte} & Unsigned 8-bit integer \\
            \texttt{i8} & & Signed 8-bit integer \\
            \hline
            \texttt{u16} & & Unsigned 16-bit integer \\
            \texttt{i16} & & Signed 16-bit integer \\
            \hline
            \texttt{u32} & & Unsigned 32-bit integer \\
            \texttt{i32} & \texttt{int} & Signed 32-bit integer \\
            \hline
            \texttt{u64} & & Unsigned 64-bit integer \\
            \texttt{i64} & \texttt{long} & Signed 64-bit integer \\
            \hline
            \texttt{f32} & \texttt{float} & 32-bit floating-point number \\
            \texttt{f64} & \texttt{double} & 64-bit floating-point number \\
            \hline
        \end{tabular}
        \caption{Primitive Types}\label{tab:primitive-types}
    \end{table}

    % TODO type hierarchy

    These types have the following type hierarchy:
    \begin{itemize}
        \item \texttt{int8 < int16 < int32 < int64}
        \item \texttt{uint8 < uint16 < uint32 < uint64}
        \item \texttt{uint\(n\) < int\((n+k)\)}
        \item \texttt{float32 < float64}
        \item \texttt{[u]int\(n\) < float64}
        \item \texttt{[u]int\(n\) < float32} where \(n < 64\).
    \end{itemize}

    Note that \texttt{bool} is not related to anything.
    Unlike in other language, \texttt{bool} is treated as a distinct type with abstract true/false values, rather than a synonym for integers 1/0, respectively.

    \subsection{The Unit Type}

    Ths unit type, denotes by empty brackets `\texttt{()}', is a special type meaning \textit{empty}.
    Representing an object with no value, it is a zero-width type, meaning a symbol of this type occupies no space.
    For examples of use, a unit is returned from a block which returns no value.

    \begin{lstlisting}[language=CustomLang]
let a = {}; // a: ()
    \end{lstlisting}

    Note that a unit is neither an r-- nor an l-value, so it cannot be used in expressions.
    That is, the below program errors before even trying to find a candidate for \texttt{+}.

    \begin{lstlisting}[language=CustomLang]
() + 1; // error: expected rvalue, got ()
    \end{lstlisting}

    \subsection{Pointer Types}\label{subsec:pointer-types}

    The use of pointers is designed to be minimal in Edel, but they are available nonetheless.
    Simply put, a pointer stores the \textit{location} (or \textit{address}) of a variable, which can then be used to later reference and access that data.
    A pointer is indicated by a star `\texttt{*}' preceding the type;
    that is, type \texttt{*T} is telling the compiler \textit{hey, see this location? Data of type} \texttt{T} \textit{is stored there}.

    Subsection ~\ref{subsec:address-of-&-dereferencing} explains the use of the \texttt{\&} and \texttt{*} unary operators to manipulate pointers.

    Pointers do not fit into the type hierarchy, and cannot be implicitly cast.
    For safety, it is best not to cast pointer types unless one really knows and understands what is going on.

    \subsection{Function Types}\label{subsec:function-types}

    % TODO

    \subsection{Casting}\label{subsec:type-casting}

    Casting refers to the changing of a type, and can be split into two categories: implicit, and explicit.
    Note that the destination type of either cast \textbf{cannot} be zero-sized.

    Implicit casting is where a cast is done behind-the-scenes.
    Type \(a\) may be implicitly cast (also known as \textit{coerced}) to another type \(b\) if and only if \(a < b\), that is, \(a\) is a subtype of \(b\).
    In other words, \(a\) can be coerced into \(b\) if \(b\) is sufficient to represent \(a\) without data loss.
    For example, \texttt{u8} may be coerced into \texttt{u64}, or \texttt{float} into \texttt{double}, but \textbf{not} \texttt{i32} into \texttt{i16}.
    Implicit casting is done automatically in the following:

    \begin{lstlisting}[language=CustomLang]
let a: double = 3.14; // float -> double
    \end{lstlisting}

    On the other hand, explicit casting violates these rules, and hence the cast may be \textit{explicit}.
    Note that not all datatypes may be cast between each-other using explicit casting, but the subtype relationships may be largely violated.

    \begin{lstlisting}[language=CustomLang]
let a: u8 = 42; // error!
let a = 42 as u8; // i32 -> u8
    \end{lstlisting}

    \section{Functions}\label{sec:functions}

    Functions are labelled blocks of code which may be called by the programmer.
    A function may take some input values, known as \textit{arguments}, and may optionally return a value.

    An example of a function which takes two integers and returns an integer:
    \begin{lstlisting}[language=CustomLang]
func add(a: int, b: int) -> int {
    return a + b;
}
    \end{lstlisting}

    That is, a function is defined using the \texttt{func} keyword, followed by a name.
    Parameters in the form \texttt{name: type} are listed, comma-separated, between brackets.
    Note that if no arguments are required, the brackets may be omitted altogether.
    The function's return type is listed after an arrow; if no return type is needed, this may be omitted.
    For example,
    \begin{lstlisting}[language=CustomLang]
func foo {
    // ...
}

func bar(a: float) { // equivalent to `-> ()'
    // ...
}
    \end{lstlisting}

    \subsection{Returning a Value}

    The \texttt{return} keyword is used to exit/return from the current function.
    Optionally, the keyword may be followed by an expression, in which case that value will be returned.
    The type of the returned expression must match, or be a subtype of, the function's return type.
    Furthermore, if the function returns a non-unit type, a return statement must be present.

    \begin{lstlisting}[language=CustomLang]
func foo {
    return 42; // error: cannot convert i32 to ()
}

func bar -> int {
} // error: missing return statement
    \end{lstlisting}

    Note that \textit{all} code paths should return, even if you, the programmer, knows that a path is never taken.
    % TODO update if constant optimisation added
    That is because the compiler cannot currently recognise, for example, always-falsy conditions.

    \begin{lstlisting}[language=CustomLang]
func foo -> int {
    if false {
    } else {
        return 42;
    }
} // error: missing return statement
    \end{lstlisting}

    \subsubsection{Unreachable Code}

    As \texttt{return} exits the function, any code after said statement is \textit{unreachable}.
    This code will never be executed, and a warning will be reported.

    \begin{lstlisting}[language=CustomLang]
func foo {
    return;
    a; // warning: unreachable code detected
}
    \end{lstlisting}

    The above code would usually result in an error, as symbol `\texttt{a}' is not defined.
    However, as the code is not reached, no error is raised.

    \subsection{Function Declaration}\label{subsec:function-declaration}

    A function declaration is one which has no body.
    For example,

    \begin{lstlisting}[language=CustomLang]
func add(a: int, b: int) -> int;
    \end{lstlisting}

    As functions in Edel do not require forward-declaration, what does this do?
    Depending on the compiler flag \texttt{--function-placeholder}, it does one of two things.

    \paragraph*{Enforce Existence}

    The default, \texttt{--no-function-placeholder}, a function declaration is used to inform the programmer about the existence of a function.
    One common use is in auto-generated standard library files, where the function exists but is implemented internally.
    If the function does not exist, an error will be raised.

    \begin{lstlisting}[language=CustomLang]
func imaginary_function(x: int) -> bool; // error: function was declared but does not exist
    \end{lstlisting}

    \paragraph*{Generate Placeholder}

    In this instance, if a function is declared but does not exist, the function will be created to return zero, `\texttt{()}', false, or null, depending on the return type.
    This is useful when a function is yet to be implemented.

    For example, the following are identical.
    \begin{lstlisting}[language=CustomLang]
func imaginary_function(x: int) -> bool;
// ==
func imaginary_function(x: int) -> bool {
    return false;
}
    \end{lstlisting}


    Note that as this generates a definition, it cannot be re-defined.

    \subsection{Function Overloading}

    A function in Edel is not only identified by its name, but also its \textit{signature}.
    The signature of a function is a combination of its name and parameter types.
    In an Edel program, a function signature must be unique, or the result would be an error.
    This means that multiple functions with the same name can exist.
    This is known as function overloading, and a variant of a function with the same name but different parameters is called an \textit{overload}.

    \begin{lstlisting}[language=CustomLang]
func add(a: int, b: int) -> int {
    return a + b;
}
func add(a: float, b: float) -> float {
    return a + b;
}
    \end{lstlisting}

    In this case, a reference to \texttt{add} no longer just refers to one symbol.
    Instead, it becomes what is known as an \textit{overload set}, and more information is required for a resolution.

    \begin{lstlisting}[language=CustomLang]
add; // error: unable to resolve symbol `add'
    \end{lstlisting}

    \subsubsection{Overload Resolution}

    This is the process by which an overload is selected.
    Firstly, a list of candidates is generated; this would be all functions with a matching name.
    A candidate is considered a match if the number of arguments match and the type of each parameter matches.
    Due to subtyping rules, the latter check may lead to the generating of multiple `matching' candidates.
    In such a case, the candidate with the highest number of identical types wins.

    \begin{lstlisting}[language=CustomLang]
func add(a: int, b: int) -> int;
func add(a: long, b: long) -> long;

add(1, 2); // signature is add(int, int)
    \end{lstlisting}

    In the above snippet, both candidates match the callee.
    However, the former wins as \texttt{int == int} while \texttt{int < long}.

    If there are still ties at this point, an error is raised as a candidate cannot be decided.
    In this case, it is best to explicitly cast one or more arguments to reach the desired candidate.

    \begin{lstlisting}[language=CustomLang]
func add(a: int, b: long) -> long;
func add(a: long, b: int) -> long;

add(1, 2); // error: unable to resolve
    \end{lstlisting}

    \section{Operators}

    Operators are special symbols which combine one or two expressions, known as unary and binary operators, respectively.
    The table below lists the built-in operators alongside their behaviour and associativity.
    Operators start from tightest to loosest precedence, with those of the same precedence grouped.

    \begin{table}[h]
        \centering
        \caption{Built-In Operators}
        \begin{tabular}{|l|l|c|c|}
            \hline
            \textbf{Operator} & \textbf{Description} & \textbf{Associativity} & \textbf{Overloadable} \\
            \hline
            \texttt{a.b} & Member access & \(\longrightarrow\) & No \\
            \hline
            \texttt{a()} & Function call & \(\longrightarrow\) & Yes \\
            \hline
            \texttt{(T) a} & Primitive cast & \multirow{4}{*}{\(\longleftarrow\)} & \multirow{4}{*}{No} \\
            \texttt{\&a} & Address-of & & \\
            \texttt{*a} & Dereference & & \\
            \texttt{registerof a} & Register lookup & & \\
            \hline
            \texttt{-a} & Negation & \multirow{3}{*}{\(\longleftarrow\)} & \multirow{3}{*}{Yes} \\
            \texttt{~a} & Bitwise NOT & & \\
            \texttt{!a} & Boolean NOT & & \\
            \hline
            \texttt{a as T} & Cast & \(\longleftarrow\) & No \\
            \hline
            \texttt{a * b} & Multiplication & \multirow{3}{*}{\(\longrightarrow\)} & \multirow{3}{*}{Yes} \\
            \texttt{a / b} & Division & & \\
            \texttt{a \% b} & Modulo (remainder) & & \\
            \hline
            \texttt{a + b} & Addition & \multirow{2}{*}{\(\longrightarrow\)} & \multirow{2}{*}{Yes} \\
            \texttt{a - b} & Subtraction & & \\
            \hline
            \texttt{a << b} & Bitwise left shift & \multirow{2}{*}{\(\longrightarrow\)} & \multirow{2}{*}{Yes} \\
            \texttt{a >> b} & Bitwise left shift & & \\
            \hline
            \texttt{a == b} & \multirow{6}{*}{Relational operators} & \multirow{6}{*}{\(\longrightarrow\)} & \multirow{6}{*}{Yes} \\
            \texttt{a != b} & & & \\
            \texttt{a < b} & & & \\
            \texttt{a <= b} & & & \\
            \texttt{a > b} & & & \\
            \texttt{a >= b} & & & \\
            \hline
            \texttt{a \& b} & Bitwise AND & \multirow{1}{*}{\(\longrightarrow\)} & Yes \\
            \hline
            \texttt{a \string^ b} & Bitwise XOR & \multirow{1}{*}{\(\longrightarrow\)} & Yes \\
            \hline
            \texttt{a | b} & Bitwise OR & \multirow{1}{*}{\(\longrightarrow\)} & Yes \\
            \hline
            \texttt{a = b} & Assignment & \multirow{1}{*}{\(\longleftarrow\)} & No \\
            \hline
        \end{tabular}\label{tab:builtin-operators}
    \end{table}

    \subsection{Casting}\label{subsec:op-casting}

    The concept of casting is explained in subsection ~\ref{subsec:type-casting}.
    Note that the table above presents two casting operators: \texttt{(T) a} and \texttt{a as T}.

    The former is a \textit{primitive} cast, meaning it only supports casting to primitive, atomic types.
    This cast is direct and is ignorant of the type of \texttt{a} and whether the cast is meaningful.

    The latter, using the \texttt{as} keyword, is a straightforward explicit cast.
    There are no restrictions on \texttt{T} and, as explained in subsection ~\ref{subsec:type-casting}, this cast still must obey some rules.

    \begin{lstlisting}[language=CustomLang]
let a = (int) 3.14; // ok
let b = (*int) 0; // error
let c = 0 as *int; // ok
    \end{lstlisting}

    Also note the difference in precedence: the \texttt{as} cast is slightly looser than other unary operators.

    \begin{lstlisting}[language=CustomLang]
!1 as bool; // same as `(!1) as bool' NOT `!(1 as bool)'
    \end{lstlisting}

    \subsection{Address-Of \& Dereferencing}\label{subsec:address-of-&-dereferencing}

    Both operations involve pointers, with the former generating pointers, and the latter `consuming' them.

    The address-of operator, \texttt{\&}, calculates the memory address of a symbol.
    That is, if \texttt{a: T}, then \texttt{\&a} is of type \texttt{*T}.

    Dereferencing, then, is address-of's twin; it retrieved the value stored at a pointer.
    That is, if \texttt{p: *T}, then \texttt{*a} is of type \texttt{T}.

    \begin{lstlisting}[language=CustomLang]
let a: int = 5;
let p: *int = &a;
let b: int = *p; // then a == b
    \end{lstlisting}

    \subsection{Register Lookup}

    This is a lower-level operator meant for exploration of the processor's registers.

    Expecting a symbol argument, the \texttt{registerof} operator returns the index (offset) of where the given symbol is located.
    This allows one to gain insight into the register allocation algorithm.

    For example, given the basic program below, one would expect the following.

    \begin{lstlisting}[language=CustomLang]
let a = 5;
registerof a; // = 11, corresponding to $r1
    \end{lstlisting}

    If the symbol has not been loaded into registers (i.e., it has not been used at all/recently), the operator returns \(-1\).

    \begin{lstlisting}[language=CustomLang]
let a: int;
registerof a; // = -1
    \end{lstlisting}

    \section{Control Flow}

    \section{Scope \& Name Resolution}\label{sec:scope}

    \section{Modules \& Imports}

    \section{Standard Library}

\end{document}
