\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{multirow}
\usepackage{float}

\include{styles/bashconsole}
\include{styles/language}

\setlength{\parindent}{0pt}

\title{Language Documentation}
\author{Ruben Saunders}
\date{January 2025}

\begin{document}
    \maketitle
    \tableofcontents

    \newpage

    \section{Introduction}\label{sec:introduction}

    This document will contain information about the Edel language.
    As an educational tool, it is designed to be simple and easy to learn and operate, with the goals of being clear a readable.
    Each section is written from the perspective of little programming knowledge.

    \subsection{Overview}\label{subsec:overview}

    As the most wide-spread paradigm, this language is imperative by nature.
    Its syntax is inspired by C, but borrows features from C++ such as namespaces and operator overloading.
    However, unlike these two languages, names are \textit{forward declared}, meaning they can be used prior to their definition.
    This foregoes the need for header files of explicit forward declarations as in C and C++, and allows a much freer programming experience similar to modern languages.

    % TODO talk about imports

    \subsection{The Compiler}\label{subsec:the-compiler}

    A program consists of one file (the entry file), which is compiled by the compiler to produce an assembly output.

    \medskip
    \begin{lstlisting}[style=bashconsole]
$ ./compiler <input_file> [-o <output_file>] [flags]
    \end{lstlisting}
    \medskip

    Where \texttt{[flags]} are as follows:
    \begin{itemize}
        \item \texttt{--ast} - prints the parsed program's AST.
    \end{itemize}
    Note that the output file is optional.

    \subsection{``Hello, World''}\label{subsec:hello-world}

    As is customary, a quick ``hello world'' program written in Edel.

    \begin{lstlisting}[language=CustomLang]
func main() {
    print("Hello, world\n");
}
    \end{lstlisting}

    \section{Basic Syntax}\label{sec:basic-syntax}

    Inspires by C, Edel is not whitespace sensitive, with scopes marked by braces \texttt{\{\}}.
    Semicolons are not requires after every line, namely closing braces, but are required after expressions.

    Comments come in two forms: single-- and multi-line.
    Single-line comments \texttt{// ...} comment out the remainder of the current line;
    multi-line comments \texttt{/* ... */} comment out anything they enclose.

    \subsection{Variables}\label{subsec:variables-&-assignment}

    Using the common analogy, a variable is like a labeled box which stored data.
    Each box has a \textit{type} which tells us what it stores.
    For example, ``int 3''.
    More technically, a variable is a location in memory where data can be stored, with its type determining the size of the variable and how its value can be used.

    Variables are defined using the \texttt{let} keyword, with the variables type following a colon.
    For example, to define our ``int 3'' from earlier,
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3;
    \end{lstlisting}

    If required, multiple variables can be defined in the same \texttt{let} statement.
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3, bar: float = 3.14;
    \end{lstlisting}

    If the type is omitted, it is deduced from the assigned value.
    Hence, this can only be done if the variable is assigned.
    \begin{lstlisting}[language=CustomLang]
let foo = 3, bar = 3.14;
    \end{lstlisting}
    (In this case, both variables adopt the types as previously written.)

    \subsubsection{Shadowing}

    Edel allows names to be \textit{shadowed}, meaning a variable may re-use a variable's name.

    In non-local shadowing, the previous definition becomes visible again after the current scope is exited.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
{
    let foo = 2;
    // foo = 2
}
// foo = 1
    \end{lstlisting}

    Edel also allows local shadowing.
    In this case, once shadowed, the previous definition is essentially lost and cannot be referenced.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
// foo = 1
let foo = 2;
// foo = 2
    \end{lstlisting}

    \subsubsection{Constants}

    Constants are values that, once defined, cannot be changed.
    Constants may be defined using the \texttt{const} keyword in place of \texttt{let}.

    \begin{lstlisting}[language=CustomLang]
const pi = 3.14159;
    \end{lstlisting}

    In the case of multiple definitions, \textit{all} symbols will be defined as const.

    \subsection{Expressions \& Statements}\label{subsec:expressions-&-statements}

    Generally, a statement is some code which does not produce a value, whereas an expression does.
    In Edel, \textit{everything} is an expression, with statements, by default, returning the unit type `\texttt{()}'.

    Expressions are expected to be terminated by a semicolon.
    The exception to this is the final expression in a block; if omitted, the block `returns' the result of this expression.

    \begin{lstlisting}[language=CustomLang]
let a = { 1 + 2; }; // a = ()
let b = { 1 + 2 }; // b = 3
let c = { let z = 2 * b; z } + 2; // c = 8
    \end{lstlisting}

    Note that only the last expression in a block may have their semicolon emitted.
    By always terminating expressions, the block will act like a statement.

    \subsubsection{Value Categories}

    Each expression, be it an operator with operands, literals, or variable names etc., is characterised by a \textit{type} and a \textit{category}.
    Types, covered in section ~\ref{sec:types}, give meaning to data and what it means in context, whereas the category tells dictates \textit{how} a value can be used.

    Edel has two categories, be them l-- and r-values.
    The former is a value which refers to a memory location, such as variables, while the latter has no identifiable location in memory.
    The \textit{l} and \textit{r} stand for \textit{left} and \textit{right} because the respective values may appear on the left-- or right-hand side of an assignment operator.
    That is,

    \begin{lstlisting}[language=CustomLang]
a = 1; // a (lvalue) = 1 (rvalue)
    \end{lstlisting}

    As an rvalue has no identifiable location, it cannot be assigned to, nor can it be access via the dot `\texttt{.}' operator.
    Instances of misuse of an l-- or rvalue results in an error ``\texttt{expected l/rvalue, got type}''.

    \begin{lstlisting}[language=CustomLang]
1 = 2; // error: expected lvalue, got i32
true.a; // error: expected lvalue, got bool

namespace maths {}
maths + 1; // error: expected rvalue, got namespace
    \end{lstlisting}

    \subsection{Code Blocks}\label{subsec:code-blocks}

    As a whitespace-ignorant language, Edel uses blocks to denote structure and scope.
    A block is introduced by braces \texttt{\{\}} and contains a section of code.
    A block may be written anywhere a statement is expected, allowing the programmer to instead write multiple statements in its body.
    Finally, in Edel, every block introduces a new lexical scope~\ref{sec:scope}.

    \section{Types}\label{sec:types}

    Continuing the analogy from variables, a type is a label that tells the program what kind of data a variable holds.
    Every variable and value has a type; a value without a type is meaningless, as a type gives data a meaning.

    \subsection{Primitive Types}

    Primitive types are a subset of those provided by the compiler representing atomic values, such as numbers.

    \medskip
    \begin{table}[H]
        \begin{tabular}{|c|c|c|l|}
            \hline
            \textbf{Type} & \textbf{Alias} & \textbf{Description} \\
            \hline
            \texttt{bool} & & A truth value -- either \texttt{true} or \texttt{false} \\
            \hline
            \texttt{u8} & \texttt{byte} & Unsigned 8-bit integer \\
            \texttt{i8} & & Signed 8-bit integer \\
            \hline
            \texttt{u16} & & Unsigned 16-bit integer \\
            \texttt{i16} & & Signed 16-bit integer \\
            \hline
            \texttt{u32} & & Unsigned 32-bit integer \\
            \texttt{i32} & \texttt{int} & Signed 32-bit integer \\
            \hline
            \texttt{u64} & & Unsigned 64-bit integer \\
            \texttt{i64} & \texttt{long} & Signed 64-bit integer \\
            \hline
            \texttt{f32} & \texttt{float} & 32-bit floating-point number \\
            \texttt{f64} & \texttt{double} & 64-bit floating-point number \\
            \hline
        \end{tabular}
        \caption{Primitive Types}\label{tab:primitive-types}
    \end{table}

    % TODO type hierarchy

    These types have the following type hierarchy:
    \begin{itemize}
        \item \texttt{int8 < int16 < int32 < int64}
        \item \texttt{uint8 < uint16 < uint32 < uint64}
        \item \texttt{uint\(n\) < int\((n+k)\)}
        \item \texttt{float32 < float64}
        \item \texttt{[u]int\(n\) < float64}
        \item \texttt{[u]int\(n\) < float32} where \(n < 64\).
    \end{itemize}

    Note that \texttt{bool} is not related to anything.
    Unlike in other language, \texttt{bool} is treated as a distinct type with abstract true/false values, rather than a synonym for integers 1/0, respectively.

    \section{Functions}

    \section{Operators}

    Operators are special symbols which combine one or two expressions, known as unary and binary operators, respectively.
    The table below lists the built-in operators alongside their behaviour and associativity.
    Operators start from tightest to loosest precedence, with those of the same precedence grouped.

    \begin{table}[h]
        \caption{Built-In Operators}
        \begin{tabular}{|l|l|c|}
            \hline
            \textbf{Operator} & \textbf{Description} & \textbf{Associativity} \\
            \hline
            \texttt{a.b} & Member access & \(\longrightarrow\) \\
            \hline
            \texttt{a()} & Function Call & \(\longrightarrow\) \\
            \hline
            \texttt{a as T} & Cast & \multirow{5}{*}{\(\longleftarrow\)} \\
            \texttt{(T) a} & Primitive cast\(^\ast\) & \\
            \texttt{-a} & Negation & \\
            \texttt{~a} & Bitwise NOT & \\
            \texttt{!a} & Boolean NOT & \\
            \hline
            \texttt{a * b} & Multiplication & \multirow{3}{*}{\(\longrightarrow\)} \\
            \texttt{a / b} & Division & \\
            \texttt{a \% b} & Modulo (remainder) & \\
            \hline
            \texttt{a + b} & Addition & \multirow{2}{*}{\(\longrightarrow\)} \\
            \texttt{a - b} & Subtraction & \\
            \hline
            \texttt{a << b} & Bitwise left shift & \multirow{2}{*}{\(\longrightarrow\)} \\
            \texttt{a >> b} & Bitwise left shift & \\
            \hline
            \texttt{a == b} & \multirow{6}{*}{Relational operators} & \multirow{6}{*}{\(\longrightarrow\)} \\
            \texttt{a != b} & & \\
            \texttt{a < b} & & \\
            \texttt{a <= b} & & \\
            \texttt{a > b} & & \\
            \texttt{a >= b} & & \\
            \hline
            \texttt{a \& b} & Bitwise AND & \multirow{1}{*}{\(\longrightarrow\)} \\
            \hline
            \texttt{a \string^ b} & Bitwise XOR & \multirow{1}{*}{\(\longrightarrow\)} \\
            \hline
            \texttt{a | b} & Bitwise OR & \multirow{1}{*}{\(\longrightarrow\)} \\
            \hline
            \texttt{a = b} & Assignment & \multirow{1}{*}{\(\longleftarrow\)} \\
            \hline
        \end{tabular}\label{tab:builtin-operators}
    \end{table}

    \((\ast)\) The term \textit{primitive} cast means that this C-style cast may only be done on primitive, atomic types such as \texttt{int} and \texttt{float}, whereas the cast using \texttt{as} may be any type.

    \section{Control Flow}

    \section{Scope \& Name Resolution}\label{sec:scope}

    \section{Modules \& Imports}

    \section{Standard Library}

\end{document}
