\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{multirow}
\usepackage{float}

\include{styles/bashconsole}
\include{styles/language}

\setlength{\parindent}{0pt}

\title{Language Documentation}
\author{Ruben Saunders}
\date{January 2025}

\begin{document}
    \maketitle
    \tableofcontents

    \newpage

    \section{Introduction}\label{sec:introduction}

    This document will contain information about the Emit language.
    As an educational tool, it is designed to be simple and easy to learn and operate, with the goals of being clear a readable.
    The name itself is simple, tied to the emission of code and an acronym for Educational Machine Instruction and Translation.
    Each section is written from the perspective of little programming knowledge.

    \subsection{Overview}\label{subsec:overview}

    As the most wide-spread paradigm, this language is imperative by nature.
    Its syntax is heavily inspired by C, but borrows features from C++ such as namespaces and operator overloading.
    However, unlike these two languages, names are \textit{forward declared}, meaning they can be used prior to their definition.
    This foregoes the need for header files of explicit forward declarations as in C and C++, and allows a much freer programming experience similar to modern languages.

    % TODO talk about imports

    \subsection{The Compiler}\label{subsec:the-compiler}

    A program consists of one file (the entry file), which is compiled by the compiler to produce an assembly output.

    \medskip
    \begin{lstlisting}[style=bashconsole]
$ ./compiler <input_file> -o <output_file> [flags]
    \end{lstlisting}
    \medskip

    \subsection{``Hello, World''}\label{subsec:hello-world}

    As is customary, a quick ``hello world'' program written in Emit.

    \begin{lstlisting}[language=CustomLang]
func main() {
    print("Hello, world\n");
}
    \end{lstlisting}

    \section{Basic Syntax}\label{sec:basic-syntax}

    Inspires by C, Emit is not whitespace sensitive, with scopes marked by braces \texttt{\{\}}.
    Semicolons are not requires after every line, namely closing braces, but are required after expressions.

    Comments come in two forms: single-- and multi-line.
    Single-line comments \texttt{// ...} comment out the remainder of the current line;
    multi-line comments \texttt{/* ... */} comment out anything they enclose.

    \subsection{Variables}\label{subsec:variables-&-assignment}

    Using the common analogy, a variable is like a labeled box which stored data.
    Each box has a \textit{type} which tells us what it stores.
    For example, ``int 3''.
    More technically, a variable is a location in memory where data can be stored, with its type determining the size of the variable and how its value can be used.

    Variables are defined using the \texttt{let} keyword, with the variables type following a colon.
    For example, to define our ``int 3'' from earlier,
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3;
    \end{lstlisting}

    If required, multiple variables can be defined in the same \texttt{let} statement.
    \begin{lstlisting}[language=CustomLang]
let foo: int = 3, bar: float = 3.14;
    \end{lstlisting}

    If the type is omitted, it is deduced from the assigned value.
    Hence, this can only be done if the variable is assigned.
    \begin{lstlisting}[language=CustomLang]
let foo = 3, bar = 3.14;
    \end{lstlisting}
    (In this case, both variables adopt the types as previously written.)

    \subsubsection{Shadowing}

    Emit allows names to be \textit{shadowed}, meaning a variable may re-use a variable's name.

    In non-local shadowing, the previous definition becomes visible again after the current scope is exited.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
{
    let foo = 2;
    // foo = 2
}
// foo = 1
    \end{lstlisting}

    Emit also allows local shadowing.
    In this case, once shadowed, the previous definition is essentially lost and cannot be referenced.
    \begin{lstlisting}[language=CustomLang]
let foo = 1;
// foo = 1
let foo = 2;
// foo = 2
    \end{lstlisting}

    \subsubsection{Constants}

    Constants are values that, once defined, cannot be changed.
    Constants may be defined using the \texttt{const} keyword in place of \texttt{let}.

    \begin{lstlisting}[language=CustomLang]
const pi = 3.14159;
    \end{lstlisting}

    In the case of multiple definitions, \textit{all} symbols will be defined as const.

    \subsection{Expressions \& Statements}\label{subsec:expressions-&-statements}

    Both statement is a piece of code that performs an action but does not necessarily produce a value.
    Examples include if statements, while loops, function definitions, etc.

    Expressions, however, produce a value.
    An expression consists of a combination of values and operators, such as \texttt{1 + 2} or \texttt{maths.sin(0.5)}.
    Expressions \textit{must} be terminated with a semicolon.

    \subsubsection{Value Categories}

    Each expression, be it an operator with operands, literals, or variable names etc., is characterised by a \textit{type} and a \textit{category}.
    Types, covered in section ~\ref{sec:types}, give meaning to data and what it means in context, whereas the category tells dictates \textit{how} a value can be used.

    Emit has two categories, be them l-- and r-values.
    The former is a value which refers to a memory location, such as variables, while the latter has no identifiable location in memory.
    The \textit{l} and \textit{r} stand for \textit{left} and \textit{right} because the respective values may appear on the left-- or right-hand side of an assignment operator.
    That is,

    \begin{lstlisting}[language=CustomLang]
a = 1; // a (lvalue) = 1 (rvalue)
    \end{lstlisting}

    As an rvalue has no identifiable location, it cannot be assigned to, nor can it be access via the dot `\texttt{.}' operator.
    Instances of misuse of an l-- or rvalue results in an error ``\texttt{expected l/rvalue, got type}''.

    \begin{lstlisting}[language=CustomLang]
1 = 2; // error: expected lvalue, got i32
true.a; // error: expected lvalue, got bool

namespace maths {}
maths + 1; // error: expected rvalue, got namespace
    \end{lstlisting}

    \subsection{Code Blocks}\label{subsec:code-blocks}

    As a whitespace-ignorant language, Emit uses blocks to denote structure and scope.
    A block is introduced by braces \texttt{\{\}} and contains a section of code.
    A block may be written anywhere a statement is expected, allowing the programmer to instead write multiple statements in its body.
    Finally, in Emit, every block introduces a new lexical scope~\ref{sec:scope}.

    \section{Types}\label{sec:types}

    Continuing the analogy from variables, a type is a label that tells the program what kind of data a variable holds.
    Every variable and value has a type; a value without a type is meaningless, as a type gives data a meaning.

    \subsection{Primitive Types}

    Primitive types are a subset of those provided by the compiler representing atomic values, such as numbers.

    \medskip
    \begin{table}[H]
        \begin{tabular}{|c|c|c|l|}
            \hline
            \textbf{Type} & \textbf{Alias} & \textbf{Description} \\
            \hline
            \texttt{bool} & & A truth value -- either \texttt{true} or \texttt{false} \\
            \hline
            \texttt{u8} & \texttt{byte} & Unsigned 8-bit integer \\
            \texttt{i8} & & Signed 8-bit integer \\
            \hline
            \texttt{u16} & & Unsigned 16-bit integer \\
            \texttt{i16} & & Signed 16-bit integer \\
            \hline
            \texttt{u32} & & Unsigned 32-bit integer \\
            \texttt{i32} & \texttt{int} & Signed 32-bit integer \\
            \hline
            \texttt{u64} & & Unsigned 64-bit integer \\
            \texttt{i64} & \texttt{long} & Signed 64-bit integer \\
            \hline
            \texttt{f32} & \texttt{float} & 32-bit floating-point number \\
            \texttt{f64} & \texttt{double} & 64-bit floating-point number \\
            \hline
        \end{tabular}
        \caption{Primitive Types}\label{tab:primitive-types}
    \end{table}

    % TODO type hierarchy

    These types have the following type hierarchy:
    \begin{itemize}
        \item \texttt{int8 < int16 < int32 < int64}
        \item \texttt{uint8 < uint16 < uint32 < uint64}
        \item \texttt{uint\(n\) < int\((n+k)\)}
        \item \texttt{float32 < float64}
        \item \texttt{[u]int\(n\) < float64}
        \item \texttt{[u]int\(n\) < float32} where \(n < 64\).
    \end{itemize}

    Note that \texttt{bool} is not related to anything.
    Unlike in other language, \texttt{bool} is treated as a distinct type with abstract true/false values, rather than a synonym for integers 1/0, respectively.

    \section{Functions}

    \section{Operators}

    Operators are special symbols which combine one or two expressions, known as unary and binary operators, respectively.
    The table below lists the built-in operators and their behaviour, along with their precedence (higher is tighter) and associativity.

    \begin{table}[h]
        \caption{Built-In Operators}
        \begin{tabular}{|c|l|l|c|}
            \hline
            \textbf{Precedence} & \textbf{Operator} & \textbf{Description} & \textbf{Associativity} \\
            \hline
            \multirow{1}{*}{20} & \texttt{a.b} & Member access \\
            \hline
            \multirow{3}{*}{14} & \texttt{a * b} & Multiplication & \multirow{3}{*}{\(\longrightarrow\)} \\
            & \texttt{a / b} & Division & \\
            & \texttt{a \% b} & Modulo (remainder) & \\
            \hline
            \multirow{2}{*}{14} & \texttt{a + b} & Addition & \multirow{2}{*}{\(\longrightarrow\)} \\
            & \texttt{a - b} & Subtraction & \\
            \hline
            \multirow{2}{*}{13} & \texttt{a << b} & Bitwise left shift & \multirow{2}{*}{\(\longrightarrow\)} \\
            & \texttt{a >> b} & Bitwise left shift & \\
            \hline
            \multirow{6}{*}{12} & \texttt{a == b} & \multirow{6}{*}{Relational operators} & \multirow{6}{*}{\(\longrightarrow\)} \\
            & \texttt{a != b} & & \\
            & \texttt{a < b} & & \\
            & \texttt{a <= b} & & \\
            & \texttt{a > b} & & \\
            & \texttt{a >= b} & & \\
            \hline
            \multirow{1}{*}{11} & \texttt{a \& b} & Bitwise AND & \multirow{1}{*}{\(\longrightarrow\)} \\
            \hline
            \multirow{1}{*}{10} & \texttt{a \string^ b} & Bitwise XOR & \multirow{1}{*}{\(\longrightarrow\)} \\
            \hline
            \multirow{1}{*}{9} & \texttt{a | b} & Bitwise OR & \multirow{1}{*}{\(\longrightarrow\)} \\
            \hline
            \multirow{1}{*}{1} & \texttt{a = b} & Assignment & \multirow{1}{*}{\(\longleftarrow\)} \\
            \hline
        \end{tabular}\label{tab:builtin-operators}
    \end{table}

    \section{Control Flow}

    \section{Scope \& Name Resolution}\label{sec:scope}

    \section{Modules \& Imports}

    \section{Standard Library}

\end{document}
