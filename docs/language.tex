\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath, amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{multirow}

\include{styles/bashconsole}
\include{styles/language}

\setlength{\parindent}{0pt}

\title{Language Documentation}
\author{Ruben Saunders}
\date{January 2025}

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Overview}

The compiler takes an entry source file and produces an assembly.

\subsection{Command-Line Interface}

The compiler executable is called as follows:

\medskip
\begin{lstlisting}[style=bashconsole]
$ ./compiler <input_file> -o <output_file> [flags]
\end{lstlisting}

The output file is provided after the \texttt{-o} flag.
The following optional flags are available:
\begin{itemize}
    \item \texttt{-d}: enables debug mode.
    In this mode, detailed results from each step are output to the console.
\end{itemize}

\section{General Syntax}

Each file is parsed into tokens, which are then grouped in recognisable sequences.
Tokens are grouped into lines; lines are separated by: a newline, unless the previous token was an operator or the parser is in a bracketed group `\texttt{(...)}';
or a semicolon `\texttt{;}'.

Each file has a global scope, which may only consist of global variables, functions, and type definitions.
Below are outlined key points about syntax; specifics will be documented later.

\begin{itemize}
    \item Single-line commends have the form \texttt{// ...} and last until a newline character is encountered.
    \item Multi-line commands have the form \texttt{/* ... */}.
    \item Identifiers start with a character which may then be followed by any number of characters, numbers, or underscores.
    That is, \texttt{[a-zA-Z][a-zA-Z0-9\_]*}.
\end{itemize}

\section{Types}

Each variable has a type, indicating tha form, size, and purpose of some data.

\paragraph*{Type Coercion}
This refers to how a value takes on a type given context, and occurs implicitly and only if necessary.
For example, the literal \texttt{42} could take on different types depending on the variable's type.
Another example would be adding two integers of different types; the smaller is coerced into the larger type.

\paragraph*{Type Casting}
This is the explicit conversion of data between two types.
Examples would be: down-sizing an integer value, changing a pointer type.
This is done by preceding a variable or value by a bracketed type.
For example,

\begin{lstlisting}[language=CustomLang]
let pi: float = 3.14159
let pi_approx: int = (int) pi
\end{lstlisting}

\subsection{Primitive Types}

The following types are provided natively.

\begin{tabular}{|c|c|c|l|}
    \hline
    \textbf{Type} & \textbf{Alias} & \textbf{Description} \\
    \hline
    \texttt{u8} & \texttt{byte} & Unsigned 8-bit integer \\
    \texttt{i8} & & Signed 8-bit integer \\
    \hline
    \texttt{u16} & & Unsigned 16-bit integer \\
    \texttt{i16} & & Signed 16-bit integer \\
    \hline
    \texttt{u32} & & Unsigned 32-bit integer \\
    \texttt{i32} & \texttt{int} & Signed 32-bit integer \\
    \hline
    \texttt{u64} & & Unsigned 64-bit integer \\
    \texttt{i64} & \texttt{long} & Signed 64-bit integer \\
    \hline
    \texttt{f32} & \texttt{float} & 32-bit floating-point number \\
    \texttt{f64} & \texttt{double} & 64-bit floating-point number \\
    \hline
\end{tabular}

\paragraph*{Numeric Literals}
Numbers are specified as a sequence of digits.
If they contain a decimal point, they become floating-point literals.
The default type for literals is \texttt{int} and \texttt{float}, respectively.
However, a literal may be given a type by suffixing it with the desired type.
E.g.,
\begin{lstlisting}[language=CustomLang]
let pi: float = 3.14
let x: u64 = 123456789u64
\end{lstlisting}

\section{Variables}

Variables are but labels to reserved location in memory.
When defined, variables are assigned a name and a datatype, which dictates the size in bytes of the reserved location.
An example would be

\begin{lstlisting}[language=CustomLang]
let x: int
\end{lstlisting}

Values may be assigned to variables using the assignment operator `\texttt{=}'.
Note the type coercion/casting behaviours described previously.

\subsection{Multi-Declaration}

Commas may be used to separate declarations and, hence, declare multiple symbols per keyword.
Each declaration may be of a different type.

\begin{lstlisting}[language=CustomLang]
let a: byte , b: int , c: long
\end{lstlisting}

\subsection{Scope}

``Scope'' refers to where a variable exists.
The global scope is the top-most scope where all top-level functions and variable reside.
Symbols in the global scope may be accessed anywhere in the program.

On the other hand, local scope is not all-encompassing.
A new local scope is introduced in every block.
Variables defined in such a scope are only accessible from within that function; referencing them outside will result in an error.

When a variable is referenced, the scopes will be searched as a stack; that is, local first, global last.

\begin{lstlisting}[language=CustomLang]
let n: int = 0

func f1 {
    n++ // this will increment the global `n'
}

func f2 {
    let n: int = 1
    n++ // this will increment the local `n' declared above
}
\end{lstlisting}

To see an example of creating a local scope that is not a function definition:

\begin{lstlisting}[language=CustomLang]
let n: int = 0 // n = 0

{
    let n: int = 2 // n = 2
    n++ // n = 3
}

// n = 0
\end{lstlisting}

\section{Functions}

Functions are name-associated sections of code which may be called, possible with arguments, and may return a value.
They are defined using the \texttt{func} keyword.
For use before definitions, signatures may be declared using the compound \texttt{decl func} keyword.

\begin{lstlisting}[language=CustomLang]
decl func add(int, int) -> int
func add(a: int, b: int) {
    return a + b
}
\end{lstlisting}

\begin{itemize}
    \item In declarations, parameter names are not required.
    \item If no parameters are required, it is possible to omit the brackets entirely.
    \item If no return type is required, omit the arrow `\texttt{->}' and the type.
    \item If declared, the definition does not require a return type as this can be inferred from its declared signature.
\end{itemize}

\subsection{Overloading}

Function overloading is supported, meaning that a function name may be re-used with a different signature.
For example,

\begin{lstlisting}[language=CustomLang]
decl func add(int, int) -> int
decl func add(float, float) -> float
\end{lstlisting}

\subsection{Entry Point}

All programs have an entry point.
By default, it is \texttt{main}, taking zero or more integers, and optionally returning an integer.

A new entry point may be defined using the \texttt{entry} keyword, by following the keyword by the entry point's name and type.
Note, this is a function signature.

\begin{lstlisting}[language=CustomLang]
entry start(int) -> int
\end{lstlisting}

Only one entry point per program is permitted.
Once encountered, future encounters of \texttt{entry} will result in an error.

\subsection{Compile-Time Functions}

These ``functions'' are resolved in the compilation stage.

\paragraph*{\texttt{sizeof(\(t\))}}
This returns the size, in bytes, of the argument \(t\).
\(t\) may be a type name, or a variable, in which case the size of the variable's type will be calculated.

\begin{lstlisting}[language=CustomLang]
sizeof(int) // -> 4
\end{lstlisting}

\paragraph*{\texttt{register(\(r\))}}
This may be used in expressions, and returns the contents of register \(r\) as a word.
\(r\) is the name of a register, same as in the assembly code but without the dollar `\texttt{\$}'.

\begin{lstlisting}[language=CustomLang]
register(sp) // reads $sp
\end{lstlisting}

\section{Operators}

Operators are special symbols which combine one or two expressions, known as unary and binary operators, respectively.
There are a subset of in-built operators, which have predetermined behaviour on certain types.
Each built-in operator has a precedence and associativity, as listed below (higher is tighter).

\begin{table}[h]
    \caption{Built-In Operators}
    \begin{tabular}{|c|l|l|}
        \hline
        \textbf{Precedence} & \textbf{Operator} & \textbf{Description} \\
        \hline
        \multirow{1}{*}{20} & \texttt{a.b} & Member access \\
        \hline
        \multirow{1}{*}{17} & \texttt{-a} & Unary minus \\
        \hline
    \end{tabular}
\end{table}

Aside from built-in operators, an operator is a sequence of any one of the following characters:
$$ \{`!', `\#', `\$', `\%', `\&', `*', `+', `.', `/', `<', `=', `>', `?', `@', `\\', `^', `|', `-', `~'\} $$

\subsection{Operator Overloading}

Operator overloading is similar to defining a new function.
For example, say we want to define \(a \sim b\) to be the distance between two numbers.

\begin{lstlisting}[language=CustomLang]
operator~(a: int, b: int) -> int {
    if a > b {
        return a - b;
    } else {
        return b - a;
    }
}
\end{lstlisting}

Note, the order of arguments matters, and the number of arguments determines if the operator is unary or binary.

\subsection{Custom Operators}

As stated above, an operator is but a sequence of symbols and, by using operator overloading, one may define behaviour for a custom operator.
In parsing, a non-built-in operator is assumed to have a precedence of 5 (i.e., weaker than every operator bar \texttt{=}) and to be left-associative.
This is to maintain associativity: \(a \sim b \sim c \equiv (a \sim b) \sim c\).

\end{document}
