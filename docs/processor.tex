\documentclass[10pt]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{makecell}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage{fancyhdr}

\include{styles/assembly}
\include{styles/c}
\include{styles/rtn}
\include{styles/bashconsole}

\title{The Processor}
\author{Ruben Saunders}
\date{September 2024}

\setcounter{tocdepth}{2}

\begin{document}

    \maketitle
    \tableofcontents

    \newpage

    \section{Principals}\label{sec:principals}

    \begin{itemize}
        \item This processor will operate a RISC instruction set.
        \item This processor has a word size of 64 bits, and supports both floats (4 bytes) and doubles (8 bytes).
        \item The instruction set will provide methods to load values into and out of registers.
        Then, most operations will be on registers.
        \item Load/store instructions operate on 32-bit immediates.
        \item Arithmetic and logic instructions operate on full registers, so 64-bit.
    \end{itemize}

    \section{Memory Layout}\label{sec:memory-layout}

    The emulator is simple, able to run only one program.

    The memory space has three regions: reserved, RAM, and stack.
    \begin{itemize}
        \item The reserved region contains two words.
        \begin{itemize}
            \item Program entry point (i.e., initial \$ip).
            \item Address of interrupt handler.
        \end{itemize}
        Note, these addresses refer to offsets in RAM.
        \item RAM is where user code is located.
        \item The stack grows downwards from the top of memory, with its base indicates via the \$sp register.
    \end{itemize}

    \section{Registers}\label{sec:registers}

    See below for a list of registers.
    There are a total of 32 registers, and are all 64 bits wide.
    Register names are preceded by a dollar `\$' sign.

    \bigskip
    \begin{longtable}{|c|l|l|l|}
        \hline
        \textbf{Symbol} & \textbf{Name} & \textbf{Bit} & \textbf{Description} \\
        \hline
        \multicolumn{4}{|c|}{\textbf{Special Registers}} \\
        \hline
        \$ip & Instruction Pointer &  & Point to next address to execute as an instruction. \\
        \hline
        \$rip & Return Address &  & \makecell[l]{Contains the sub-routiune return address.\\%
        Must be pushed onto the stack as it is not preserved.} \\
        \hline
        \$sp & Stack Pointer &  & Top address of the stack. \\
        \hline
        \$fp & Frame Pointer &  & Point to the next byte beyond the last stack frame. \\
        \hline
        \$flag & Flag Register & 9--64 & \\
        \cline{3-4}
        & & 8 & \makecell[l]{Interrupt status: 1=in interrupt, 0=normal.\\%
        Can be used to disable all interrupts.} \\
        \cline{3-4}
        & & 5--7 & \makecell[l]{Error flag.\\%
        \(\bullet\;\) 000: no error.\\%
        \(\bullet\;\) 001: invalid opcode, opcode in \$ret.\\%
        \(\bullet\;\) 010: segfault, address in \$ret.\\%
        \(\bullet\;\) 011: register segfault, register offset in \$ret.\\%
        \(\bullet\;\) 100: invalid syscall, opcode in \$ret.\\%
        \(\bullet\;\) 101: invalid datatype, bit field in \$ret.\\%
        } \\
        \cline{3-4}
        & & 4 & \makecell[l]{Execution status: 1=executing, 0=halted.\\%
        Can be used to halt the processor.} \\
        \cline{3-4}
        & & 3 & \makecell[l]{Zero flag.\\%
        Indicates if register is zero.\\%
        Updated on most instructions' dest register.} \\
        \cline{3-4}
        & & 0--2 & \makecell[l]{Comparison bits.\\%
        \(\bullet\;\) 000: not equal.\\%
        \(\bullet\;\) 001: equal.\\%
        \(\bullet\;\) 010: less than.\\%
        \(\bullet\;\) 011: less than or equal to.\\%
        \(\bullet\;\) 110: greater than.\\%
        \(\bullet\;\) 111: greater than or equal to.\\%
        } \\
        \hline
        \$isr & Interrupt Service Register & & \makecell[l]{Used to indicate active interrupts.\\%
        64-bits, so 64 available distinguishable interrupts.\\%
        By setting any bit, the processor enters an interrupt state.} \\
        \hline
        \$imr & Interrupt Mask Register & & \makecell[l]{Used to mask \$isr.\\%
        That is, interrupt \$isr[\(i\)] only triggers if \$imr[\(i\)] is set.\\%
        \textbf{Default}: all bits set.} \\
        \hline
        \$iip & Interrupt IP & & \makecell[l]{Stores \$ip in occurence of an interrupt.} \\
        \hline
        \$ret & Return Value Register & & \makecell[l]{Contains value returned from function, syscall, etc.\\%
        Contains process exit code on halt.} \\
        \hline \hline
        \multicolumn{4}{|c|}{\textbf{General Purpose Registers}} \\
        \hline
        \$k1, \$k2 & Internal Registers & & \makecell[l]{Used by pseudo-instructions.} \\
        \hline
        \$r1 -- \$r21 & General &  & Register for general use. \\
        \hline
    \end{longtable}

    \section{Addressing Modes}\label{sec:addressing-modes}

    An argument may be one of the following specifiers:

    \medskip
    \begin{tabular}{|c|c|l|l|}
        \hline
        \textbf{Argument} & \textbf{Size} & \textbf{Comment} & \textbf{Example} \\
        \hline
        \texttt{<reg>} & 8 & Register offset. & \texttt{\$r1} \\
        \hline
        \texttt{<value>} & 2 + 32 & \makecell[l]{Any listed addressing mode.\\%
        2 indicator bits, 32 for data.} & \texttt{0xdead} \\
        \hline
        \texttt{<addr>} & 1 + 32 & \makecell[l]{Any listed memory addressing mode.\\%
        1 indicator bit, 32 for data.} & \texttt{(0x8000)} \\
        \hline
    \end{tabular}
    \medskip

    The following table specifies possible addressing modes.

    \medskip
    \begin{tabular}{|c|l|l|l|l|}
        \hline
        \textbf{Indicator} & \textbf{Name} & \textbf{Syntax} & \textbf{Operation} & \textbf{Size} \\
        \hline
        00 & Immediate & \texttt{imm} & \texttt{imm} & 32 \\
        01 & Register & \texttt{\$reg} & \texttt{Reg[\$reg]} & 8 \\
        10 & Memory & \texttt{(mem)} & \texttt{Mem[mem]} & 32\\
        11 & Register Indirect & \texttt{n(\$reg)} & \texttt{Mem[Reg[\$reg] + n]} & \texttt{\$reg}=8, \texttt{\$n}=24 \\
        \hline
    \end{tabular}

    \section{Instruction Set}\label{sec:instruction-set}

    \include{assets/instructions}

    \subsection{Pseudo-Instructions}\label{subsec:pseudo-instructions}

    These are instructions which are not necessary for full functionality, but are provided for usefulness.
    They may be implemented using other instructions.
    It is up to the implementer whether to implement these as actual instructions or expand them to their equivalent form.

    \subsection{Instruction Layout}\label{subsec:instruction-layout}

    All instructions are encoded in a single 64-bit word.
    The layouts of various types is listed below.
    The size field stated the size in bits of this field.
    From top-to-bottom, the table starts at the least-significant bit.

    \textbf{Note}, the opcode of each instruction is not decided upon; it may be any value as long as the instruction set is implemented.
    The only exception is \texttt{nop}, which maps to a fully-zeroed word.

    \paragraph{Generic Layout}
    This outlines the generic structure of an instruction.
    The first section of the table refers to the `header'.

    \bigskip
    \begin{tabular}{|c|l|l|}
        \hline
        \textbf{Bit} & \textbf{Purpose} & \textbf{Comments} \\
        \hline
        0--5 & Opcode & \\
        \hline
        6--9 & Conditional test & \makecell[l]{These bits are tested against \$flag to determine if instruction is executed or skipped.\\%
        \(\bullet\;\) 1111: skip test.\\%
        \(\bullet\;\) 1001: test if zero flag is set.\\%
        \(\bullet\;\) 1000: test if zero flag is unset.\\%
        \(\bullet\;\) Otherwise: match lower 3 bits to \$flag.} \\
        \hline
        \hline
        10--64 & \multicolumn{2}{l|}{Instruction dependant.} \\
        \hline
    \end{tabular}

    \paragraph{Conditional Test}
    Most instructions expect a conditional test field.
    Below shows the mapping between suffix and bit field.

    \medskip
    \begin{tabular}{|c|c|c|l|}
        \hline
        \textbf{Suffix} & \textbf{Bits} & \textbf{Operator} & \textbf{Comments} \\
        \hline
        N/A & \texttt{1111} & N/A & Skip test. \\
        \hline
        ne / neq & \texttt{0000} & \(\neq\) & Test if not equal. \\
        eq & \texttt{0001} & \(=\) & Test if equal. \\
        \hline
        lt & \texttt{0010} & \(<\) & Test if less than. \\
        le / lte & \texttt{0011} & \(\le\) & Test if less than or equal to. \\
        \hline
        gt & \texttt{0110} & \(>\) & Test if greater than. \\
        ge / gte & \texttt{0111} & \(\ge\) & Test if greater than or equal to. \\
        \hline
        z & \texttt{1001} & \(= 0\) & Test if zero flag is set. \\
        nz & \texttt{1000} & \(\neq 0\) & Test if zero flag is clear. \\
        \hline
    \end{tabular}

    \paragraph{Data-Type Indicator}
    Some instructions have a field to specify the data-type of the data being operated on.
    These bits are after the ordinary header, and are as follows:

    \bigskip
    \begin{tabular}{|c|c|c||c|l|}
        \hline
        \makecell[c]{\textbf{Bit 0}\\Decimal?} & \makecell[c]{\textbf{Bit 1}\\Signed?} & \makecell[c]{\textbf{Bit 0}\\Full or half word?} & \textbf{Suffix} & \textbf{Comments} \\
        \hline
        0 & 0 & 0 & hu & 32-bit unsigned integer. \\
        \hline
        0 & 0 & 1 & [u] & 64-bit unsigned integer. \\
        \hline
        0 & 1 & 0 & hi & 32-bit signed integer. \\
        \hline
        0 & 1 & 1 & i & 64-bit signed integer. \\
        \hline
        1 & 0 & 0 & f & 32-bit float. \\
        \hline
        1 & 0 & 1 & d & 64-bit double. \\
        \hline
    \end{tabular}

    \bigskip
    Datatypes may be interpreted slightly differently, depending on the instruction.

    \begin{itemize}
        \item Arithmetic operations: the datatype refers to the type of the first data to be operated on.
        The last argument is always considered a 32-bit signed integer or float.
        That is, in \texttt{add.u \$r1, -75}, \texttt{\$r1} is assumed to hold an unsigned 64-bit integer, but \texttt{-75} is a 32-bit signed integer, while the result also be an unsigned 64-bit integer.

    \end{itemize}

    \section{Interrupts}\label{sec:interrupts}

    Interrupts are events which, when triggered, alert the processor immediately.
    Interrupts are triggered via the \$isr register and may be used to distinguish between different sources.
    The \$isr is used to mask, or ignore, some interrupts.
    Note that the interrupt bit must be cleared manually.
    Also note that while in an interrupt, no other interrupt can be handled.

    Below is listed C pseudocode for the fetch-execute cycle to understand interrupt behaviour:

    \begin{lstlisting}[style=c,label={lst:lstlisting}]
    void fetch_execute_cycle(void) {
        if (($isr & $imr) && !($flag & FLAG_IN_INTERRUPT)) {
            handle_interrupt();
        }

        word instruction = fetch();
        execute(instruction);

        $ip += sizeof(word);
    }

    void handle_interrupt(void) {
        $iip = $ip;
        $flag |= FLAG_IN_INTERRUPT;
        $ip = HANDLER_OFFSET;
    }

    void return_from_interrupt(void) {
        $ip = $iip;
        $flag &= ~FLAG_IN_INTERRUPT;
    }
    \end{lstlisting}

    \textbf{Note} the handler offset is at the fixed memory location \texttt{0x400}.

%    \section{Calling Convention}\label{sec:calling-convention}
%
%    Despite being a RISC processor, this processor will support explicit \texttt{call} and \texttt{ret} functions which will aid in pushing and popping a stack frame.
%    For ease of programming, multiple actions are taken in each to maintain structure, so they are not pseudo-instructions.
%
%    \subsection{Function Invocation}\label{subsec:function-invocation}
%
%    To call a function [at] \texttt{func} with \(n\) arguments:
%
%    \medskip
%    \texttt{%
%    push <arg1>\\%
%    ...\\%
%    push <arg\(n\)>\\%
%    push \(n \times 4\)\\%
%    call <func>
%    }
%
%    \medskip
%    \begin{tabular}{|r l||r l|}
%         \hline
%         \multicolumn{4}{|c|}{\textbf{Stack}} \\
%         \hline
%         \multicolumn{2}{|c||}{\textbf{Before}} & \multicolumn{2}{c|}{\textbf{After}} \\
%         \hline
%         & & preserved GP registers & \(\leftarrow\) \$sp \\
%         & & old ip & \\
%         & & old fp & \(\leftarrow\) \$fp \\
%         & & \(n\) bytes & \\
%         & & args & \\
%         \texttt{xxx} & \(\leftarrow\) \$sp & \texttt{xxx} & \\
%         \hline
%    \end{tabular}
%    \medskip
%
%    See the following points of clarification:
%    \begin{itemize}
%        \item When zero arguments are passed, still \texttt{push 0} to indicate this.
%        \item PGPRs are pushed starting \$s1 through \$s8.
%        \item All pushed values are words, except \(n\), which is a half-word (4 bytes).
%        This \(n\) states the size of the \texttt{args} region in \textbf{bytes}.
%    \end{itemize}
%
%    \subsection{Function Returning}\label{subsec:function-returning}
%
%    To return from the function invoked in the previous sub-section, we need only a call to \texttt{ret}.
%    This will restore and pop the stack frame, as well as handle any arguments the user pushed.
%    The following operations take place:
%
%    \texttt{%
%    Reg[\$ip] = old ip\\%
%    Reg[\$fp] = old fp\\%
%    Reg[\$sp] = loc(xxx)\\%
%    }
%
%    \subsection{Argument Retrieval}\label{subsec:argument-retrieval}
%
%    The frame pointer points to the top of the previous frame.
%    Using the diagram above, it is possible to retrieve an argument from the stack.
%    It is important to note that the size of the additional information pushed via the processor may theoretically vary, and so referencing and relying on knowledge of this size is unadvised.
%
%    \begin{center}
%        \(i\): argument index, 0-indexed; \(n\): number of arguments.
%
%        \texttt{Arg \(i\) = Reg[\$fp] - 4 * (2 + \(n\) - \(i\))}
%
%        E.g., to load the one and only argument: \texttt{load \$reg, 12(\$fp)}.
%    \end{center}

    \section{Subroutines}\label{sec:subroutines}

    As a RISC processor, little support is provided by the processor for calling subroutines;
    instead, it is up to compilers or other softwares to decide upon and implement such a convention.

    The process provides one instruction -- \texttt{jal} -- to handle calling a subroutine.
    Given the location in memory of the subroutine, it first caches the old instruction pointer, then loads in the subroutine's address.
    Note that this return address is not preserved, and hence must be cached by the programmer if multiple nested calls are required, lest the previous return address be overwritten.

    To return from a subroutine is simple: load the contents of this cache into the instruction pointer register.

    \section{System Call}\label{sec:system-call}

    System calls are core functionality abstracted inside the processor.
    Actions are assigned operation codes and invoked via \texttt{syscall <opcode>}.
    Optionally, each read arguments from general-purpose registers \texttt{r1} onward.

    \bigskip
    \begin{longtable}{|c|c|l|l|l|}
        \hline
        \textbf{Service} & \textbf{Opcode} & \textbf{Arguments} & \textbf{Operation} & \textbf{Result} \\
        \hline
        \multicolumn{5}{|c|}{\textbf{Output}} \\
        \hline
        print\_hex & 0 & \texttt{\$r1} = integer & Print register as hexadecimal. & \textit{None} \\
        \hline
        print\_int & 1 & \texttt{\$r1} = integer & Print 64-bit integer. & \textit{None} \\
        \hline
        print\_float & 2 & \texttt{\$r1} = float & Print 32-bit float. & \textit{None} \\
        \hline
        print\_double & 3 & \texttt{\$r1} = double & Print 64-bit double. & \textit{None} \\
        \hline
        print\_char & 4 & \texttt{\$r1} = byte & Print byte as ASCII character. & \textit{None} \\
        \hline
        print\_string & 5 & \texttt{\$r1} = string address & Print null-terminated string at the address. & \textit{None} \\
        \hline \hline
        \multicolumn{5}{|c|}{\textbf{Input}} \\
        \hline
        read\_int & 6 & \textit{None} & Read a signed 64-bit integer. & \texttt{\$ret} = integer \\
        \hline
        read\_float & 7 & \textit{None} & Read a 32-bit float. & \texttt{\$ret} = float \\
        \hline
        read\_double & 8 & \textit{None} & Read a 64-bit double. & \texttt{\$ret} = double \\
        \hline
        read\_char & 9 & \textit{None} & Read an ASCII character. & \texttt{\$ret} = character \\
        \hline
        read\_string & 10 & \makecell[l]{\texttt{\$r1} = string address\\%
        \texttt{\$r2} = max length} & \makecell[l]{Read a null-terminated string into given address.\\%
        String is truncated to maximum length.} & \textit{None} \\
        \hline \hline
        \multicolumn{5}{|c|}{\textbf{Program Flow}} \\
        \hline
        exit & 11 & \textit{None} & \makecell[l]{Exit program.\\%
        \textbf{Note} process exit code is located in \$ret.} & \textit{None} \\
        \hline \hline
        \multicolumn{5}{|c|}{\textbf{Debug}} \\
        \hline
        print\_regs & 100 & \textit{None} & Print hexadecimal value of each register. & \textit{None} \\
        \hline
        print\_mem & 101 & \makecell[l]{\texttt{\$r1} = start address\\%
        \texttt{\$r2} = segment length} & Print hexadecimal bytes of memory segment. & \textit{None} \\
        \hline
        print\_stack & 102 & \textit{None} & Print bytes of the stack. & \textit{None} \\
        \hline
    \end{longtable}

    \section{Application Overview}

    The application, named \texttt{processor}, is a simple program which implements the processor detailed therein.
    It is called as follows:

    \medskip
    \begin{lstlisting}[style=bashconsole]
$ ./processor <source_file> [flags]
    \end{lstlisting}

    Where the program has the following flags:
    \begin{itemize}
        \item \texttt{-o <output\_file>} - defaults to \texttt{stdout}, output is written here (not including debug messages).
        \item \texttt{-i <input\_file>} - defaults to \texttt{stdin}, input is read from here.
        \item \texttt{-d$x$} - toggles the $x$ debug flag, where $x$ is one of
        \begin{itemize}
            \item \texttt{all} - enables all debug flags.
            \item \texttt{cond} - checks on the conditional guard on instructions (only emitted when a guard is present).
            \item \texttt{cpu} - operation execution messages.
            \item \texttt{err} - print more detailed error messages (rather than relying solely on internal error handling).
            \item \texttt{mem} - memory (RAM) reads and writes.
            \item \texttt{out <file>} - redirect debug messages to the given file.
            \item \texttt{reg} - register reads and writes.
            \item \texttt{zflag} - updates to the \texttt{zero} flag.
        \end{itemize}
    \end{itemize}
\end{document}
