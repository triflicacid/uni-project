\section{Types}\label{sec:types}

Continuing the analogy from variables, a type is a label that tells the program what kind of data a variable holds.
Every variable and value has a type; a value without a type is meaningless, as a type gives data a meaning.

\subsection{Primitive Types}

Primitive types are a subset of those provided by the compiler representing atomic values, such as numbers.

\medskip
\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|l|}
        \hline
        \textbf{Type} & \textbf{Alias} & \textbf{Description} \\
        \hline
        \texttt{bool} & & A truth value -- either \texttt{true} or \texttt{false} \\
        \hline
        \texttt{u8} & \texttt{byte} & Unsigned 8-bit integer \\
        \texttt{i8} & & Signed 8-bit integer \\
        \hline
        \texttt{u16} & & Unsigned 16-bit integer \\
        \texttt{i16} & & Signed 16-bit integer \\
        \hline
        \texttt{u32} & & Unsigned 32-bit integer \\
        \texttt{i32} & \texttt{int} & Signed 32-bit integer \\
        \hline
        \texttt{u64} & & Unsigned 64-bit integer \\
        \texttt{i64} & \texttt{long} & Signed 64-bit integer \\
        \hline
        \texttt{f32} & \texttt{float} & 32-bit floating-point number \\
        \texttt{f64} & \texttt{double} & 64-bit floating-point number \\
        \hline
    \end{tabular}
    \caption{Primitive Types}\label{tab:primitive-types}
\end{table}

% TODO type hierarchy

These types have the following type hierarchy:
\begin{itemize}
    \item \texttt{int8 < int16 < int32 < int64}
    \item \texttt{uint8 < uint16 < uint32 < uint64}
    \item \texttt{uint\(n\) < int\((n+k)\)}
    \item \texttt{float32 < float64}
    \item \texttt{[u]int\(n\) < float64}
    \item \texttt{[u]int\(n\) < float32} where \(n < 64\).
\end{itemize}

Note that \texttt{bool} is not related to anything.
Unlike in other language, \texttt{bool} is treated as a distinct type with abstract true/false values, rather than a synonym for integers 1/0, respectively.

\subsection{The Unit Type}

Ths unit type, denoted by empty brackets `\texttt{()}', is a special type meaning \textit{empty}.
Representing an object with no value, it is a zero-width type, meaning a symbol of this type occupies no space.
For examples of use, a unit is returned from a block which returns no value.

\begin{lstlisting}[language=CustomLang]
let a = {}; // a: ()
\end{lstlisting}

\subsubsection{Zero-Sized Types}

It has been mentioned that \texttt{()} is a zero-sized type, meaning it takes up no physical space.
These types exist purely for type-checking and compile-time enforcement of constraints but do not contribute to a program's memory footprint.

\begin{lstlisting}[language=CustomLang]
operator +(a: int, b: ()) {
    return ();
}
let ans = 1 + (); // = ()
\end{lstlisting}

In the above snippet, as \texttt{a} has type \texttt{()}, it does not occupy any space on the stack.
However, the assignment expression is still executed, despite the result of \texttt{()}, to ensure any side-effects are captured.

\subsection{Pointer Types}\label{subsec:pointer-types}

The use of pointers is designed to be minimal in Edel, but they are available nonetheless.
Simply put, a pointer stores the \textit{location} (or \textit{address}) of a variable, which can then be used to later reference and access that data.
A pointer is indicated by a star `\texttt{*}' preceding the type;
that is, type \texttt{*T} is telling the compiler \textit{this is a location, and data of type } \texttt{T} \textit{is stored there}.

Subsection ~\ref{subsec:address-of-&-dereferencing} explains the use of the \texttt{\&} and \texttt{*} unary operators to manipulate pointers.

Pointers do not fit into the type hierarchy, and cannot be implicitly cast.
For safety, it is best not to cast pointer types unless absolutely necessary.

\subsection{Function Types}\label{subsec:function-types}

Every function has a function type, with its type describing its argument and return types.
A function t ype consists of a bracket-enclosed, comma-separated list of argument types, followed by an arrow and the return type.
Unlike in function definitions, an argument type list and return type are necessary.
For example,

\begin{lstlisting}[language=CustomLang]
let a: (int) -> int;
let b: (int) -> ();
let c: () -> ();
\end{lstlisting}

A symbol with a functional type can then be called as if it were a function.
% TODO: initial value
However, before calling, the symbol \textbf{must} be assigned to.
Unlike overloading, when assigning to a functional type, the functional type must be an exact match.

\begin{lstlisting}[language=CustomLang]
func abs(a: int) -> int {
    return if a > 0 { a } else { -a };
}

let f: (int) -> int = abs;
let result = f(-25);
\end{lstlisting}

\subsection{Casting}\label{subsec:type-casting}

Casting refers to the changing of a type, and can be split into two categories: implicit, and explicit.
Note that the destination type of either cast \textbf{cannot} be zero-sized.

Implicit casting is where a cast is done behind-the-scenes.
Type \(a\) may be implicitly cast (also known as \textit{coerced}) to another type \(b\) if and only if \(a < b\), that is, \(a\) is a subtype of \(b\).
In other words, \(a\) can be coerced into \(b\) if \(b\) is sufficient to represent \(a\) without data loss.
For example, \texttt{u8} may be coerced into \texttt{u64}, or \texttt{float} into \texttt{double}, but \textbf{not} \texttt{i32} into \texttt{i16}.
Implicit casting is done automatically in the following:

\begin{lstlisting}[language=CustomLang]
let a: double = 3.14; // float -> double
\end{lstlisting}

On the other hand, a cast which violates the type hierarchy must be \textit{explicit}.
Note that not all datatypes may be cast between each-other using explicit casting, but the subtype relationships may be largely violated.

\begin{lstlisting}[language=CustomLang]
let a: u8 = 42; // error!
let a = 42 as u8; // ok
\end{lstlisting}

\subsubsection{Casting Constraints}

Implicit casting is constrained by subtyping as dictated in the subtype graph.
Explicit casting allows the programmer to circumvent many of these rules, but it is not a completely unconstrained process.

The constraints are as follows: say we have the following cast:
\begin{lstlisting}[language=CustomLang]
let a: T1;
a as T2;
\end{lstlisting}

This cast is invalid if:
\begin{itemize}
    \item \texttt{T2} is a function type and neither of the following are true:
    \begin{itemize}
        \item \texttt{T1} is a pointer; or
        \item \texttt{T1} is also a functional type, and \texttt{T1 == T2}.
    \end{itemize}
    \item \texttt{T2} is a pointer, but \texttt{T1} is not.
\end{itemize}

\subsection{Type ``Hints''}\label{subsec:type-hints}

To explain this concept, consider the following situation: referring to an overloaded function.
For example,

\begin{lstlisting}[language=CustomLang]
func add(a: int, b: int) -> int {
    return a + b;
}

func add(a: float, b: float) -> float {
    return a + b;
}

add; // error: unable to resolve overloaded symbol 'add'
\end{lstlisting}

This makes sense, as the compiler has no idea which overload of \texttt{add} the programmer wants.
This is where type hints come in.
In certain scenarios where the desired type is known, this context can act as a prompt to the compiler on which overload the programmer desires.
For example, in the following, the programmer is assigning to a variable of type \texttt{(int, int) -> int}, so the compiler deduces which overload they want.

\begin{lstlisting}[language=CustomLang]
let f: (int, int) -> int = add;
\end{lstlisting}

This also occurs during casting:

\begin{lstlisting}[language=CustomLang]
add as (int, int) -> int;
\end{lstlisting}

And when determining the arguments to a non-overloaded function.

\begin{lstlisting}[language=CustomLang]
func apply(x: int, y: int, f: (int, int) -> int) -> int {
    return f(x, y);
}

apply(1, 2, add);
\end{lstlisting}

Note, this only works for non-overloaded functions, as otherwise the ``target'' type for each argument is not known.
This is also useful when obtaining a pointer to an overloaded function, as \texttt{\&} expects a symbol.

\begin{lstlisting}[language=CustomLang]
let ptr = &(add as (int, int) -> int); // error
let ptr = &add as *(int, int) -> int; // ok
\end{lstlisting}
