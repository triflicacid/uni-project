\section{Names \& Scope}\label{sec:names-&-scope}

A \textit{name} in Edel refers to an identifier, which includes functions, variables, and namespaces.
All names have a \textit{scope}, which is the area in which that name exists/may be referenced.
That is, outside its scope, a symbol does not exist.

The outermost scope is known as the \textit{global} scope.
Names defined here will be available anywhere in the current file.

The counterpart is the \textit{local} scope, which refers to the latest scope.
New scopes are created by using code blocks, for example, in while loops and functions.

\subsection{Variables}\label{subsec:variables}

Using the common analogy, a variable is like a labeled box which stored data.
Each box has a \textit{type} which tells us what it stores.
For example, ``int 3''.
More technically, a variable is a location in memory where data can be stored, with its type determining the size of the variable and how its value can be used.

Variables are defined using the \texttt{let} keyword, with the variables type following a colon.
For example, to define our ``int 3'' from earlier,
\begin{lstlisting}[language=CustomLang]
let foo: int = 3;
\end{lstlisting}

If required, multiple variables can be defined in the same \texttt{let} statement.
\begin{lstlisting}[language=CustomLang]
let foo: int = 3, bar: float = 3.14;
\end{lstlisting}

If the type is omitted, it is deduced from the assigned value.
Hence, this can only be done if the variable is assigned.
\begin{lstlisting}[language=CustomLang]
let foo = 3, bar = 3.14;
\end{lstlisting}
(In this case, both variables adopt the types as previously written.)

\subsubsection{Shadowing}

Edel allows names to be \textit{shadowed}, meaning a variable may re-use a variable's name.

In non-local shadowing, the previous definition becomes visible again after the current scope is exited.
\begin{lstlisting}[language=CustomLang]
let foo = 1;
{
    let foo = 2;
    // foo = 2
}
// foo = 1
\end{lstlisting}

Edel also allows local shadowing.
In this case, once shadowed, the previous definition is essentially lost and cannot be referenced.
\begin{lstlisting}[language=CustomLang]
let foo = 1;
// foo = 1
let foo = 2;
// foo = 2
\end{lstlisting}

\subsubsection{Constants}

Constants are values that, once defined, cannot be changed.
Constants may be defined using the \texttt{const} keyword in place of \texttt{let}.

\begin{lstlisting}[language=CustomLang]
const pi = 3.14159;
\end{lstlisting}

In the case of multiple definitions, \textit{all} symbols will be defined as const.

\subsection{Namespaces}

Namespaces allow the programmer to group related names in an environment.
Not only does this aid in organisation, but also helps to prevent naming collisions.
Note that this does \textbf{not} create a new lexical scope.

A namespace is created using the \texttt{namespace} keyword, and may contain any structure which is permitted at the global level.

\begin{lstlisting}[language=CustomLang]
namespace maths {
    func cos(x: double) -> double;
}
\end{lstlisting}

To reference a name outside the namespace, its name must be prefixed by the namespace's name.

\begin{lstlisting}[language=CustomLang]
cos(0); // error: unable to resolve symbol `sin'
maths.cos(0); // = 1
\end{lstlisting}

Unlike variables, namespaces cannot be shadowed.
Note that the \texttt{namespace} keyword only creates a namespace if it does not already exist.
If it does, then the declarations will be added to the existing namespace.
For example, the below snippet would result in the definitions of the two functions \texttt{maths.sin} and \texttt{maths.cos}.

\begin{lstlisting}[language=CustomLang]
namespace maths {
    func sin(x: double) -> double;
}
namespace maths {
    func cos(x: double) -> double;
}
\end{lstlisting}

\subsubsection{Nested Namespaces}

Namespaces may be nested explicitly as follows.

\begin{lstlisting}[language=CustomLang]
namespace std {
    namespace maths {
        func cos(x: double) -> double;
    }
}
maths.cos; // error: cannot resolve symbol `maths'
std.maths.cos; // ok
\end{lstlisting}

However, namespace names may contain paths, that is, multiple identifiers joined by the dot `\texttt{.}' operator.
This would be equivalent to explicitly nesting each identifier as a namespace.
For example, one may re-write the above snippet as

\begin{lstlisting}[language=CustomLang]
namespace std.maths {
    func cos(x: double) -> double;
}
\end{lstlisting}

\subsection{The Discard Symbol, `\texttt{\_}'}

The discard symbol, `\texttt{\_}', is a special identifier meant in instances where the result/value is intended to be discarded.
It cannot be used as a general identifier, with its special uses outlined below.
For example, it cannot be used as a function or namespace name.

\subsubsection{In Let Statements}

This symbol may be used in a let statement.
In this case, an assignment is required, and the variable \textbf{cannot} have a type annotation.
While the right-hand side will be evaluated, no assignment will take place.

\begin{lstlisting}[language=CustomLang]
let _: int; // error: expected assignment
let _: int = 1 + 2; // error: cannot have a type annotation
let _ = 1 + 2;
\end{lstlisting}

\subsubsection{As a Parameter Name}

Another use is for function parameters.
Unlike ordinary parameters, this symbol may be re-used for multiple parameters.
Then, as this symbol cannot be referenced, this is equivalent to ``throwing away'' the parameter.

\begin{lstlisting}[language=CustomLang]
func middle(_: int, x: int, _: int) -> int {
    return x;
}
\end{lstlisting}
