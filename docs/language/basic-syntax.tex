\section{Basic Syntax}\label{sec:basic-syntax}

Inspired by C, Edel is not whitespace sensitive, with scopes marked by braces \texttt{\{\}}.
Semicolons are not requires after every line, namely closing braces, but are required after expressions.

Comments come in two forms: single-- and multi-line.
Single-line comments \texttt{// ...} comment out the remainder of the current line;
multi-line comments \texttt{/* ... */} comment out anything they enclose.

\subsection{Expressions \& Statements}\label{subsec:expressions-&-statements}

Generally, a statement is some code which does not produce a value, whereas an expression does.
In Edel, \textit{everything} is an expression, with statements, by default, returning the unit type `\texttt{()}'.

Expressions are expected to be terminated by a semicolon.
The exception to this is the final expression in a block; if omitted, the block `returns' the result of this expression.

\begin{lstlisting}[language=CustomLang]
let a = { 1 + 2; }; // a = ()
let b = { 1 + 2 }; // b = 3
let c = { let z = 2 * b; z } + 2; // c = 8
\end{lstlisting}

Note that only the last expression in a block may have their semicolon emitted.
By always terminating expressions, the block will act like a statement.

\subsubsection{Value Categories}

Each expression, be it an operator with operands, literals, or variable names etc., is characterised by a \textit{type} and a \textit{category}.
Types, covered in section ~\ref{sec:types}, give meaning to data and what it means in context, whereas the category tells dictates \textit{how} a value can be used.

Edel has two categories, be them l-- and r-values.
The former is a value which refers to a memory location, such as variables, while the latter has no identifiable location in memory.
The \textit{l} and \textit{r} stand for \textit{left} and \textit{right} because the respective values may appear on the left-- or right-hand side of an assignment operator.
That is,

\begin{lstlisting}[language=CustomLang]
a = 1; // a (lvalue) = 1 (rvalue)
\end{lstlisting}

As an rvalue has no identifiable location, it cannot be assigned to, nor can it be access via the dot `\texttt{.}' operator.
Instances of misuse of an l-- or rvalue results in an error ``\texttt{expected l/rvalue, got type}''.

\begin{lstlisting}[language=CustomLang]
1 = 2; // error: expected lvalue, got i32
true.a; // error: expected lvalue, got bool

namespace maths {}
maths + 1; // error: expected rvalue, got namespace
\end{lstlisting}

\subsubsection{Values are Copied}

An important thing to note is that, when values are passed around, such as function arguments and during assignment, they are \textbf{copied}.
Therefore, care should be taken to avoid accidental copying when it is neither desired nor required.

For example, note the following where the original array is not mutated as the argument is copied.

\begin{lstlisting}[language=CustomLang]
func useless(arr: [int; 5]) {
    arr[0] = 1;
}

let a: [int; 5]; // a[0] = 0
useless(a);
// a[0] = 0 still
\end{lstlisting}

If this mutation behaviour was desired, pointers should be used.

\begin{lstlisting}[language=CustomLang]
func useful(arr: *[int; 5]) {
    (*arr)[0] = 1;
}

let a: [int; 5]; // a[0] = 0
useful(a);
// a[0] = 1
\end{lstlisting}

\subsection{Code Blocks}\label{subsec:code-blocks}

As a whitespace-ignorant language, Edel uses blocks to denote structure and scope.
A block is introduced by braces \texttt{\{\}} and contains a section of code.
As previously mentioned, a block may be an expression or a statement, hence is permitted anywhere they would be expected.

Blocks in Edel introduce a new lexical scope (see section ~\ref{sec:names-&-scope} for scope resolution).

\subsection{Literals}

A literal is an rvalue represented directly in the code, such as integers and Booleans.
As an rvalue, each literal has a type (see section ~\ref{sec:types}).

\subsubsection{Booleans}

A Boolean is a binary value, with each Boolean being \texttt{true} or \texttt{false}.

\begin{lstlisting}[language=CustomLang]
true;
false;
\end{lstlisting}

\subsubsection{Numbers}

Numbers can be divided into two categories: integers, or whole numbers, and floating-point numbers.
Both consists of a sequence of digits, with the latter containing a decimal point.

\begin{lstlisting}[language=CustomLang]
12;
3.14159;
\end{lstlisting}

The default type of each category is \texttt{int} and \texttt{float}, respectively.
If a specific type is required, this may appear as a suffix.
For example,

\begin{lstlisting}[language=CustomLang]
12u8;
3.1415f64;
\end{lstlisting}

Note that the type of a literal is determined lazily.
That is, the type is only determined when the literal is required.
For example, the following integer is parsed as a \texttt{u8} rather than as an \texttt{int} before being cast to a \texttt{u8}.

\begin{lstlisting}[language=CustomLang]
12 as u8;
\end{lstlisting}

\subsubsection{Null}

The \texttt{null} keyword is used to denote an empty pointer/function value.
\texttt{null} can be through of as the following.

\begin{lstlisting}[language=CustomLang]
let null: *u8 = 0;
\end{lstlisting}

(Note this is not well-formed code, as the cast would fail, and \texttt{null} is a keyword.)

As with numeric literals, \texttt{null}'s type is also determined in-context.
\texttt{null} may be used as any pointer type, as well as a functional type.

\begin{lstlisting}[language=CustomLang]
let ptr = null as *i32;
let fn = null as (int) -> int;
\end{lstlisting}

\subsubsection{Arrays}

Array literals represent static array types, such as \texttt{[int; 5]}.
An array literal is a comma-seperated list of expressions enclosed in square brackets.
The type of an array literal, if not explicitly provided, is taken from the type of the first element.

\begin{lstlisting}[language=CustomLang]
let a = [1]; // ok, [int; 1]
let b = [1, 3.4]; // error: cannot convert float to int
let c: [float; 2] = [1, 3.4]; // ok
\end{lstlisting}
